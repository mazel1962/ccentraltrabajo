import {
  add,
  addDays,
  addMonths,
  addYears,
  differenceInCalendarDays,
  eachDayOfInterval,
  endOfWeek,
  format,
  getDay,
  getHours,
  getISOWeek,
  getMinutes,
  getMonth,
  getSeconds,
  getYear,
  isAfter,
  isBefore,
  isDate,
  isEqual,
  isValid,
  parse,
  parseISO,
  set,
  setHours,
  setMilliseconds,
  setMinutes,
  setMonth,
  setSeconds,
  setYear,
  startOfWeek,
  sub,
  subMonths,
  subYears
} from "./chunk-CQS23ZPE.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentScope,
  guardReactiveProps,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUpdate,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  toRef,
  unref,
  useSlots,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-QRO6HSH3.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-JXMXRRTK.js";

// node_modules/@vuepic/vue-datepicker/dist/vue-datepicker.es.js
var st = (e, a) => {
  const n = e.__vccOpts || e;
  for (const [t, c] of a)
    n[t] = c;
  return n;
};
var Ia = {};
var Ya = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var Ea = createBaseVNode("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1);
var Fa = createBaseVNode("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var Ka = createBaseVNode("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var Ha = createBaseVNode("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1);
var Wa = [
  Ea,
  Fa,
  Ka,
  Ha
];
function Ua(e, a) {
  return openBlock(), createElementBlock("svg", Ya, Wa);
}
var Ht = st(Ia, [["render", Ua]]);
var La = {};
var Ga = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var ja = createBaseVNode("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1);
var za = createBaseVNode("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var Xa = [
  ja,
  za
];
function qa(e, a) {
  return openBlock(), createElementBlock("svg", Ga, Xa);
}
var Ja = st(La, [["render", qa]]);
var Za = {};
var Qa = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var xa = createBaseVNode("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var el = [
  xa
];
function tl(e, a) {
  return openBlock(), createElementBlock("svg", Qa, el);
}
var Mn = st(Za, [["render", tl]]);
var nl = {};
var al = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var ll = createBaseVNode("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1);
var rl = [
  ll
];
function sl(e, a) {
  return openBlock(), createElementBlock("svg", al, rl);
}
var Sn = st(nl, [["render", sl]]);
var ol = {};
var ul = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var il = createBaseVNode("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1);
var dl = createBaseVNode("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var cl = [
  il,
  dl
];
function fl(e, a) {
  return openBlock(), createElementBlock("svg", ul, cl);
}
var Wn = st(ol, [["render", fl]]);
var ml = {};
var vl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var yl = createBaseVNode("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var pl = [
  yl
];
function hl(e, a) {
  return openBlock(), createElementBlock("svg", vl, pl);
}
var Un = st(ml, [["render", hl]]);
var gl = {};
var wl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var kl = createBaseVNode("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var bl = [
  kl
];
function $l(e, a) {
  return openBlock(), createElementBlock("svg", wl, bl);
}
var Ln = st(gl, [["render", $l]]);
var An = (e, a) => {
  const n = parse(e, a.slice(0, e.length), new Date());
  return isValid(n) && isDate(n) ? n : null;
};
var zt = (e, a) => {
  if (typeof a == "string")
    return An(e, a);
  if (Array.isArray(a)) {
    let n = null;
    for (let t = 0; t < a.length && (n = An(e, a[t]), !n); t++)
      ;
    return n;
  }
  return typeof a == "function" ? a(e) : null;
};
var Ye = (e) => {
  let a = new Date(JSON.parse(JSON.stringify(e)));
  return a = setHours(a, 0), a = setMinutes(a, 0), a = setSeconds(a, 0), a = setMilliseconds(a, 0), a;
};
var rn = (e) => Array.isArray(e) ? isValid(e[0]) && (e[1] ? isValid(e[1]) : true) : e ? isValid(e) : false;
var Se = (e, a, n, t) => {
  let c = e ? new Date(e) : new Date();
  return (a || a === 0) && (c = setHours(c, +a)), (n || n === 0) && (c = setMinutes(c, +n)), (t || t === 0) && (c = setSeconds(c, +t)), setMilliseconds(c, 0);
};
var Dl = (e) => {
  const a = addMonths(e, 1);
  return { month: getMonth(a), year: getYear(a) };
};
var rt = (e, a, n) => {
  let t = e ? new Date(e) : new Date();
  return (a || a === 0) && (t = setMonth(t, a)), n && (t = setYear(t, n)), t;
};
var Pn = (e, a) => e ? `HH:mm${a ? ":ss" : ""}` : `hh:mm${a ? ":ss" : ""} aa`;
var Gn = (e, a, n, t, c, m, v, y) => e || (t ? "MM/yyyy" : c ? Pn(a, n) : m ? "MM/dd/yyyy" : v ? "yyyy" : y ? `MM/dd/yyyy, ${Pn(a, n)}` : "MM/dd/yyyy");
var Xt = (e) => {
  const a = e || new Date();
  return {
    hours: getHours(a),
    minutes: getMinutes(a),
    seconds: getSeconds(a)
  };
};
var Nt = (e) => ({ month: getMonth(e), year: getYear(e) });
var Cn = (e) => Array.isArray(e) ? [Nt(e[0]), e[1] ? Nt(e[1]) : null] : Nt(e);
var sn = (e) => Array.isArray(e) ? [Xt(e[0]), Xt(e[1])] : Xt(e);
var qt = (e, a, n) => n ? format(e, a, { locale: n }) : format(e, a);
var mt = (e, a, n, t, c) => Array.isArray(e) ? `${qt(e[0], a, n)} ${c && !e[1] ? "" : t || "-"} ${e[1] ? qt(e[1], a, n) : ""}` : qt(e, a, n);
var De = (e, a) => !e || !a ? false : isAfter(Ye(e), Ye(a));
var ke = (e, a) => !e || !a ? false : isBefore(Ye(e), Ye(a));
var ue = (e, a) => !e || !a ? false : isEqual(Ye(e), Ye(a));
var Ml = (e, a) => add(set(new Date(), e), a);
var Sl = (e, a) => sub(set(new Date(), e), a);
var Jt = (e) => set(new Date(), { hours: getHours(e), minutes: getMinutes(e), seconds: getSeconds(e) });
var Tn = (e) => set(new Date(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
});
var ct = (e, a, n, t) => {
  if (!e)
    return true;
  if (t) {
    const c = n === "max" ? isBefore(e, a) : isAfter(e, a), m = { seconds: 0, milliseconds: 0 };
    return c || isEqual(set(e, m), set(a, m));
  }
  return n === "max" ? e.getTime() <= a.getTime() : e.getTime() >= a.getTime();
};
var on = (e, a, n, t, c) => {
  let m = true;
  if (!e)
    return true;
  const v = !c && !t ? Array.isArray(e) ? [e[0] ? Jt(e[0]) : null, e[1] ? Jt(e[1]) : null] : Jt(e) : e;
  if (a || t) {
    const y = a ? Tn(a) : new Date(t);
    Array.isArray(v) ? m = ct(v[0], y, "max", !!t) && ct(v[1], y, "max", !!t) : m = ct(v, y, "max", !!t);
  }
  if (n || c) {
    const y = n ? Tn(n) : new Date(c);
    Array.isArray(v) ? m = ct(v[0], y, "min", !!c) && ct(v[1], y, "min", !!c) && m : m = ct(v, y, "min", !!c) && m;
  }
  return m;
};
var Al = (e, a, n) => {
  let t = true;
  return a && n && (t = De(new Date(e), new Date(a)) && ke(new Date(e), new Date(n))), a && (t = De(new Date(e), new Date(a))), n && (t = ke(new Date(e), new Date(n))), t;
};
var Ie = (e) => e instanceof Date ? e : parseISO(e);
var Zt = (e, a) => {
  if (a) {
    const t = new Date().getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - t).toISOString();
  }
  const n = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
  return new Date(n).toISOString();
};
var jn = (e, a, n) => e && e[0] && e[1] ? De(n, e[0]) && ke(n, e[1]) : e && e[0] && a ? De(n, e[0]) && ke(n, a) || ke(n, e[0]) && De(n, a) : false;
var Tt = (e, a) => {
  const n = startOfWeek(e, { weekStartsOn: a }), t = endOfWeek(e, { weekStartsOn: a });
  return [n, t];
};
var zn = (e, a) => Array.isArray(a) ? a.some((n) => ue(Ie(new Date(n)), Ie(e))) : a(e);
var Pl = (e, a, n, t, c, m, v, y) => {
  const h = n ? De(Ie(e), Ie(n)) : false, M = a ? ke(Ie(e), Ie(a)) : false, R = zn(e, t), Y = (m.months.length ? m.months.map((l) => +l) : []).includes(getMonth(e)), O = v.length ? v.some((l) => +l === getDay(e)) : false, L = c.length ? !c.some((l) => ue(Ie(l), Ie(e))) : false, T = getYear(e), te = T < +y[0] || T > +y[1];
  return !(h || M || R || Y || te || O || L);
};
var Xn = (e, a, n, t, c, m, v) => ({
  validate: (h) => Pl(h, e, a, n, t, c, m, v)
});
var ze = Symbol();
var Wt = Symbol();
var vn = Symbol();
var qn = Symbol();
var Jn = Symbol();
var Xe = Symbol();
var yn = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  autoApply: { type: Boolean, default: false },
  inline: { type: Boolean, default: false },
  textInput: { type: Boolean, default: false }
};
var pn = {
  range: { type: Boolean, default: false },
  uid: { type: String, default: null }
};
var Zn = {
  enableSeconds: { type: Boolean, default: false },
  is24: { type: Boolean, default: true },
  noHoursOverlay: { type: Boolean, default: false },
  noMinutesOverlay: { type: Boolean, default: false },
  noSecondsOverlay: { type: Boolean, default: false },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 }
};
var Qn = __spreadProps(__spreadValues({}, Zn), {
  fixedStart: { type: Boolean, default: false },
  fixedEnd: { type: Boolean, default: false },
  timePicker: { type: Boolean, default: false }
});
var xn = {
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: false },
  clearable: { type: Boolean, default: true },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: false },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: false },
  textInputOptions: { type: Object, default: () => null }
};
var ea = {
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null }
};
var hn = {
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null }
};
var ta = __spreadValues({
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: false },
  partialRange: { type: Boolean, default: true }
}, ea);
var gn = {
  monthPicker: { type: Boolean, default: false },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: false },
  modelAuto: { type: Boolean, default: false }
};
var na = {
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: { type: Boolean, default: false },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: false },
  monthChangeOnScroll: { type: [Boolean, String], default: true },
  dayNames: {
    type: [Function, Array],
    default: null
  }
};
var aa = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, Qn), ta), gn), hn), na), pn), {
  vertical: { type: Boolean, default: false },
  disableMonthYearSelect: { type: Boolean, default: false },
  menuClassName: { type: String, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: false },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: true },
  autoApply: { type: Boolean, default: false },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  monthYearComponent: { type: Object, default: null },
  timePickerComponent: { type: Object, default: null },
  actionRowComponent: { type: Object, default: null },
  hideOffsetDates: { type: Boolean, default: false },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: false },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: false },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: true },
  spaceConfirm: { type: Boolean, default: true },
  monthChangeOnArrows: { type: Boolean, default: true },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: false },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: false },
  keepActionRow: { type: Boolean, default: false },
  weekPicker: { type: Boolean, default: false },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: false },
  multiStatic: { type: Boolean, default: true },
  disableTimeRangeValidation: { type: Boolean, default: false },
  highlight: {
    type: [Array, Function],
    default: null
  },
  teleportCenter: { type: Boolean, default: false }
});
var Cl = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, xn), yn), aa), {
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: false },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: false },
  autoPosition: { type: Boolean, default: true },
  closeOnAutoApply: { type: Boolean, default: true },
  teleport: { type: [String, Object], default: "body" },
  altPosition: { type: [Boolean, Function], default: false },
  transitions: { type: [Boolean, Object], default: true },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: false },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 }
});
var la = {
  range: { type: Boolean, default: false },
  multiCalendars: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null }
};
var ra = __spreadProps(__spreadValues(__spreadValues({}, gn), la), {
  vertical: { type: Boolean, default: false },
  month: { type: Number, default: 0 },
  year: { type: Number, default: 0 },
  instance: { type: Number, default: 1 }
});
var Tl = ["aria-label", "aria-disabled", "aria-readonly"];
var _l = {
  key: 1,
  class: "dp__input_wrap"
};
var Rl = ["id", "name", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"];
var Vl = {
  key: 2,
  class: "dp__input_icon"
};
var Bl = {
  key: 4,
  class: "dp__clear_icon"
};
var Ol = defineComponent({
  __name: "DatepickerInput",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, xn), yn), pn), {
    inputValue: { type: String, default: "" },
    inline: { type: Boolean, default: false },
    isMenuOpen: { type: Boolean, default: false },
    pattern: { type: String, default: "" }
  }),
  emits: [
    "clear",
    "open",
    "update:inputValue",
    "setInputDate",
    "close",
    "selectDate",
    "setEmptyDate",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = ref(), m = ref(null), v = ref(false), y = inject(ze), h = computed(() => ({
      dp__pointer: !t.disabled && !t.readonly && !t.textInput,
      dp__disabled: t.disabled,
      dp__input_readonly: !t.textInput,
      dp__input: true,
      dp__input_icon_pad: !t.hideInputIcon,
      dp__input_valid: t.state,
      dp__input_invalid: t.state === false,
      dp__input_focus: v.value || t.isMenuOpen,
      dp__input_reg: !t.textInput,
      [t.inputClassName]: !!t.inputClassName
    })), M = (o) => {
      var U;
      const { value: F } = o.target, { format: J, rangeSeparator: _ } = t.textInputOptions;
      if (F !== "") {
        if (((U = t.textInputOptions) == null ? void 0 : U.openMenu) && !t.isMenuOpen && n("open"), t.range) {
          const [z, Z] = F.split(`${_}`);
          if (z && Z) {
            const Q = zt(z.trim(), J || t.pattern), j = zt(Z.trim(), J || t.pattern);
            c.value = Q && j ? [Q, j] : null;
          }
        } else
          c.value = zt(F, J || t.pattern);
        n("setInputDate", c.value);
      } else
        n("setInputDate", null), t.autoApply && (n("setEmptyDate"), c.value = null);
      n("update:inputValue", F);
    }, R = () => {
      var o, F;
      ((o = t.textInputOptions) == null ? void 0 : o.enterSubmit) && rn(c.value) && t.inputValue !== "" ? (n("setInputDate", c.value, true), c.value = null) : ((F = t.textInputOptions) == null ? void 0 : F.enterSubmit) && t.inputValue === "" && (c.value = null, n("clear"));
    }, B = () => {
      var o, F;
      ((o = t.textInputOptions) == null ? void 0 : o.tabSubmit) && rn(c.value) && t.inputValue !== "" ? (n("setInputDate", c.value, true), c.value = null) : ((F = t.textInputOptions) == null ? void 0 : F.tabSubmit) && t.inputValue === "" && (c.value = null, n("clear"));
    }, Y = () => {
      v.value = true, n("focus");
    }, O = (o) => {
      var F;
      o.preventDefault(), o.stopImmediatePropagation(), o.stopPropagation(), t.textInput && ((F = t.textInputOptions) == null ? void 0 : F.openMenu) ? t.isMenuOpen ? t.textInputOptions.enterSubmit && n("selectDate") : n("open") : t.textInput || n("toggle");
    }, L = () => {
      v.value = false, t.isMenuOpen || n("blur"), t.autoApply && t.textInput && c.value && (n("setInputDate", c.value), n("selectDate"), c.value = null);
    }, T = () => {
      n("clear");
    }, te = (o) => {
      t.textInput || o.preventDefault();
    };
    return a({
      focusInput: () => {
        m.value && m.value.focus({ preventScroll: true });
      }
    }), (o, F) => (openBlock(), createElementBlock("div", {
      onClick: O,
      "aria-label": unref(y).input,
      role: "textbox",
      "aria-multiline": "false",
      "aria-disabled": o.disabled,
      "aria-readonly": o.readonly
    }, [
      o.$slots.trigger && !o.$slots["dp-input"] && !e.inline ? renderSlot(o.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
      !o.$slots.trigger && (!e.inline || o.inlineWithInput) ? (openBlock(), createElementBlock("div", _l, [
        o.$slots["dp-input"] && !o.$slots.trigger && !e.inline ? renderSlot(o.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          onInput: M,
          onEnter: R,
          onTab: B,
          onClear: T
        }) : createCommentVNode("", true),
        o.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
          key: 1,
          ref_key: "inputRef",
          ref: m,
          id: o.uid ? `dp-input-${o.uid}` : void 0,
          name: o.name,
          class: normalizeClass(unref(h)),
          placeholder: o.placeholder,
          disabled: o.disabled,
          readonly: o.readonly,
          required: o.required,
          value: e.inputValue,
          autocomplete: o.autocomplete,
          onInput: M,
          onKeydown: [
            withKeys(O, ["enter"]),
            withKeys(B, ["tab"])
          ],
          onBlur: L,
          onFocus: Y,
          onKeypress: te
        }, null, 42, Rl)),
        o.$slots["input-icon"] && !o.hideInputIcon ? (openBlock(), createElementBlock("span", Vl, [
          renderSlot(o.$slots, "input-icon")
        ])) : createCommentVNode("", true),
        !o.$slots["input-icon"] && !o.hideInputIcon && !o.$slots["dp-input"] ? (openBlock(), createBlock(unref(Ht), {
          key: 3,
          class: "dp__input_icon dp__input_icons"
        })) : createCommentVNode("", true),
        o.$slots["clear-icon"] && e.inputValue && o.clearable && !o.disabled && !o.readonly ? (openBlock(), createElementBlock("span", Bl, [
          renderSlot(o.$slots, "clear-icon", { clear: T })
        ])) : createCommentVNode("", true),
        o.clearable && !o.$slots["clear-icon"] && e.inputValue && !o.disabled && !o.readonly ? (openBlock(), createBlock(unref(Ja), {
          key: 5,
          class: "dp__clear_icon dp__input_icons",
          onClick: withModifiers(T, ["stop", "prevent"])
        }, null, 8, ["onClick"])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ], 8, Tl));
  }
});
var Nl = (e, a, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), c = [];
  for (let m = 0; m < 7; m++) {
    const v = addDays(t, m), y = getMonth(v) !== a;
    c.push({
      text: n && y ? "" : v.getDate(),
      value: v,
      current: !y
    });
  }
  return c;
};
var Il = (e, a, n, t) => {
  const c = [], m = new Date(a, e), v = new Date(a, e + 1, 0), y = startOfWeek(m, { weekStartsOn: n }), h = (M) => {
    const R = Nl(M, e, t);
    if (c.push({ days: R }), !c[c.length - 1].days.some((B) => ue(Ye(B.value), Ye(v)))) {
      const B = addDays(M, 7);
      h(B);
    }
  };
  return h(y), c;
};
var Yl = (e, a = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += a)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
};
var El = (e, a) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((m) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${m}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, a), c = n.slice(a + 1, n.length);
  return [n[a]].concat(...c).concat(...t);
};
var Fl = (e) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: `${n}` });
  return a;
};
var Kl = (e, a) => {
  const n = new Intl.DateTimeFormat(e, { month: a, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((c) => {
    const m = c < 10 ? `0${c}` : c;
    return new Date(`2017-${m}-01T00:00:00+00:00`);
  }).map((c, m) => ({
    text: n.format(c),
    value: m
  }));
};
var Hl = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e];
var Wl = () => ({
  enterSubmit: true,
  tabSubmit: true,
  openMenu: true,
  rangeSeparator: " - "
});
var Ul = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e);
var Ll = (e) => {
  function n(t) {
    let c = "";
    const m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", v = m.length;
    for (let y = 0; y < t; y++)
      c += m.charAt(Math.floor(Math.random() * v));
    return c + e;
  }
  return n(5);
};
var we = (e) => {
  var n;
  const a = unref(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
};
var Gl = (e) => Object.assign({ type: "dot" }, e);
var _n = (e) => Object.assign({
  menuAppear: "dp-menu-appear",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down"
}, e);
var jl = (e) => Object.assign({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  calendarWrap: "Calendar wrapper",
  calendarDays: "Calendar days",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (a) => `Increment ${a}`,
  decrementValue: (a) => `Decrement ${a}`,
  openTpOverlay: (a) => `Open ${a} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month"
}, e);
var sa = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : false;
var oe = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
});
var Qt = ref(null);
var _t = ref(false);
var xt = ref(false);
var en = ref(false);
var tn = ref(false);
var $e = ref(0);
var he = ref(0);
var qe = () => {
  const e = computed(() => _t.value ? [...oe.selectionGrid, oe.actionRow].filter((l) => l.length) : xt.value ? [
    ...oe.timePicker[0],
    ...oe.timePicker[1],
    tn.value ? [] : [Qt.value],
    oe.actionRow
  ].filter((l) => l.length) : en.value ? [...oe.monthPicker, oe.actionRow] : [oe.monthYear, ...oe.calendar, oe.time, oe.actionRow].filter((l) => l.length)), a = (l) => {
    $e.value = l ? $e.value + 1 : $e.value - 1;
    let o = null;
    e.value[he.value] && (o = e.value[he.value][$e.value]), o || ($e.value = l ? $e.value - 1 : $e.value + 1);
  }, n = (l) => {
    if (he.value === 0 && !l || he.value === e.value.length && l)
      return;
    he.value = l ? he.value + 1 : he.value - 1, e.value[he.value] ? e.value[he.value] && !e.value[he.value][$e.value] && $e.value !== 0 && ($e.value = e.value[he.value].length - 1) : he.value = l ? he.value - 1 : he.value + 1;
  }, t = (l) => {
    let o = null;
    e.value[he.value] && (o = e.value[he.value][$e.value]), o ? o.focus({ preventScroll: !_t.value }) : $e.value = l ? $e.value - 1 : $e.value + 1;
  }, c = () => {
    a(true), t(true);
  }, m = () => {
    a(false), t(false);
  }, v = () => {
    n(false), t(true);
  }, y = () => {
    n(true), t(true);
  }, h = (l, o) => {
    oe[o] = l;
  }, M = (l, o) => {
    oe[o] = l;
  }, R = () => {
    $e.value = 0, he.value = 0;
  };
  return {
    buildMatrix: h,
    buildMultiLevelMatrix: M,
    setTimePickerBackRef: (l) => {
      Qt.value = l;
    },
    setSelectionGrid: (l) => {
      _t.value = l, R(), l || (oe.selectionGrid = []);
    },
    setTimePicker: (l, o = false) => {
      xt.value = l, tn.value = o, R(), l || (oe.timePicker[0] = [], oe.timePicker[1] = []);
    },
    setTimePickerElements: (l, o = 0) => {
      oe.timePicker[o] = l;
    },
    arrowRight: c,
    arrowLeft: m,
    arrowUp: v,
    arrowDown: y,
    clearArrowNav: () => {
      oe.monthYear = [], oe.calendar = [], oe.time = [], oe.actionRow = [], oe.selectionGrid = [], oe.timePicker[0] = [], oe.timePicker[1] = [], _t.value = false, xt.value = false, tn.value = false, en.value = false, R(), Qt.value = null;
    },
    setMonthPicker: (l) => {
      en.value = l, R();
    }
  };
};
var zl = ["aria-label"];
var Xl = {
  class: "dp__calendar_header",
  role: "row"
};
var ql = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
};
var Jl = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1);
var Zl = ["aria-label"];
var Ql = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
};
var xl = { class: "dp__cell_inner" };
var er = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var tr = createBaseVNode("div", { class: "dp__arrow_bottom_tp" }, null, -1);
var nr = defineComponent({
  __name: "Calendar",
  props: __spreadProps(__spreadValues(__spreadValues({}, ra), na), {
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    modeHeight: { type: [Number, String], default: 255 },
    specificMode: { type: Boolean, default: false }
  }),
  emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe"],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = ref(null), m = ref({ bottom: "", left: "", transform: "" }), v = ref([]), y = ref(null), h = ref(true), M = inject(Wt), R = inject(ze), B = inject(Xe), Y = ref(""), O = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), L = computed(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : El(t.locale, +t.weekStart)), { buildMultiLevelMatrix: T } = qe();
    onMounted(() => {
      n("mount", { cmp: "calendar", refs: v }), t.noSwipe || y.value && (y.value.addEventListener("touchstart", Z, { passive: false }), y.value.addEventListener("touchend", Q, { passive: false }), y.value.addEventListener("touchmove", j, { passive: false })), t.monthChangeOnScroll && y.value && y.value.addEventListener("wheel", i, { passive: false });
    });
    const te = (s, w) => {
      if (M != null && M.value) {
        const E = Ye(rt(new Date(), t.month, t.year));
        Y.value = De(Ye(rt(new Date(), s, w)), E) ? M.value[t.vertical ? "vNext" : "next"] : M.value[t.vertical ? "vPrevious" : "previous"], h.value = false, nextTick(() => {
          h.value = true;
        });
      }
    }, l = computed(() => ({
      dp__calendar_wrap: true,
      [t.calendarClassName]: !!t.calendarClassName
    })), o = computed(() => (s) => {
      const w = Gl(s);
      return {
        dp__marker_dot: w.type === "dot",
        dp__marker_line: w.type === "line"
      };
    }), F = computed(() => (s) => ue(s, c.value)), J = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: t.multiCalendars > 0 && t.instance !== 0
    })), _ = computed(() => t.specificMode ? { height: `${t.modeHeight}px` } : null), U = (s, w, E) => {
      var ee, I;
      if (n("setHoverDate", s), (I = (ee = s.marker) == null ? void 0 : ee.tooltip) != null && I.length) {
        const re = we(v.value[w][E]);
        if (re) {
          const { width: p, height: P } = re.getBoundingClientRect();
          m.value = {
            bottom: `${P}px`,
            left: `${p / 2}px`,
            transform: "translateX(-50%)"
          }, c.value = s.value;
        }
      }
    }, z = () => {
      c.value = null;
    }, Z = (s) => {
      O.value.startX = s.changedTouches[0].screenX, O.value.startY = s.changedTouches[0].screenY;
    }, Q = (s) => {
      O.value.endX = s.changedTouches[0].screenX, O.value.endY = s.changedTouches[0].screenY, D();
    }, j = (s) => {
      s.preventDefault();
    }, D = () => {
      const s = t.vertical ? "Y" : "X";
      Math.abs(O.value[`start${s}`] - O.value[`end${s}`]) > 10 && n("handleSwipe", O.value[`start${s}`] > O.value[`end${s}`] ? "right" : "left");
    }, $ = (s, w, E) => {
      s && (Array.isArray(v.value[w]) ? v.value[w][E] = s : v.value[w] = [s]), B != null && B.value && T(v.value, "calendar");
    }, i = (s) => {
      t.monthChangeOnScroll && (s.preventDefault(), n("handleScroll", s));
    };
    return a({ triggerTransition: te }), (s, w) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(J))
    }, [
      createBaseVNode("div", {
        style: normalizeStyle(unref(_))
      }, [
        e.specificMode ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "calendarWrapRef",
          ref: y,
          class: normalizeClass(unref(l)),
          role: "grid",
          "aria-label": unref(R).calendarWrap
        }, [
          createBaseVNode("div", Xl, [
            s.weekNumbers ? (openBlock(), createElementBlock("div", ql, toDisplayString(s.weekNumName), 1)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(L), (E, ee) => (openBlock(), createElementBlock("div", {
              class: "dp__calendar_header_item",
              role: "gridcell",
              key: ee
            }, [
              s.$slots["calendar-header"] ? renderSlot(s.$slots, "calendar-header", {
                key: 0,
                day: E,
                index: ee
              }) : createCommentVNode("", true),
              s.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(E), 1)
              ], 64))
            ]))), 128))
          ]),
          Jl,
          createVNode(Transition, {
            name: Y.value,
            css: !!unref(M)
          }, {
            default: withCtx(() => [
              h.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "dp__calendar",
                role: "grid",
                "aria-label": unref(R).calendarDays
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(e.mappedDates, (E, ee) => (openBlock(), createElementBlock("div", {
                  class: "dp__calendar_row",
                  role: "row",
                  key: ee
                }, [
                  s.weekNumbers ? (openBlock(), createElementBlock("div", Ql, [
                    createBaseVNode("div", xl, toDisplayString(e.getWeekNum(E.days)), 1)
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(E.days, (I, re) => (openBlock(), createElementBlock("div", {
                    role: "gridcell",
                    class: "dp__calendar_item",
                    ref_for: true,
                    ref: (p) => $(p, ee, re),
                    key: re + ee,
                    "aria-selected": I.classData.dp__active_date || I.classData.dp__range_start || I.classData.dp__range_start,
                    "aria-disabled": I.classData.dp__cell_disabled,
                    tabindex: "0",
                    onClick: withModifiers((p) => s.$emit("selectDate", I), ["stop", "prevent"]),
                    onKeydown: withKeys((p) => s.$emit("selectDate", I), ["enter"]),
                    onMouseover: (p) => U(I, ee, re),
                    onMouseleave: z
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["dp__cell_inner", I.classData])
                    }, [
                      s.$slots.day ? renderSlot(s.$slots, "day", {
                        key: 0,
                        day: +I.text,
                        date: I.value
                      }) : createCommentVNode("", true),
                      s.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(I.text), 1)
                      ], 64)),
                      I.marker ? (openBlock(), createElementBlock("div", {
                        key: 2,
                        class: normalizeClass(unref(o)(I.marker)),
                        style: normalizeStyle(I.marker.color ? { backgroundColor: I.marker.color } : {})
                      }, null, 6)) : createCommentVNode("", true),
                      unref(F)(I.value) ? (openBlock(), createElementBlock("div", {
                        key: 3,
                        class: "dp__marker_tooltip",
                        style: normalizeStyle(m.value)
                      }, [
                        createBaseVNode("div", {
                          class: "dp__tooltip_content",
                          onClick: w[0] || (w[0] = withModifiers(() => {
                          }, ["stop"]))
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(I.marker.tooltip, (p, P) => (openBlock(), createElementBlock("div", {
                            key: P,
                            class: "dp__tooltip_text"
                          }, [
                            s.$slots["marker-tooltip"] ? renderSlot(s.$slots, "marker-tooltip", {
                              key: 0,
                              tooltop: p,
                              day: I.value
                            }) : createCommentVNode("", true),
                            s.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createBaseVNode("div", {
                                class: "dp__tooltip_mark",
                                style: normalizeStyle(p.color ? { backgroundColor: p.color } : {})
                              }, null, 4),
                              createBaseVNode("div", null, toDisplayString(p.text), 1)
                            ], 64))
                          ]))), 128)),
                          tr
                        ])
                      ], 4)) : createCommentVNode("", true)
                    ], 2)
                  ], 40, er))), 128))
                ]))), 128))
              ], 8, Zl)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ], 10, zl))
      ], 4)
    ], 2));
  }
});
var ar = (e) => typeof e == "object";
var Rn = (e, a) => a;
var lr = (e) => Array.isArray(e) && e.length === 2;
var rr = (e) => Array.isArray(e);
var sr = (e) => typeof e == "object";
var bt = (e) => Array.isArray(e);
var _e = (e) => Array.isArray(e);
var It = (e) => Array.isArray(e) && e.length === 2;
var or = (e, a) => a ? Array.isArray(e) : It(e);
var ur = (e) => Array.isArray(e);
var ir = (e) => typeof e == "string" || typeof e == "object" || typeof e == "number";
var Vn = (e) => typeof e == "string";
var dr = { class: "dp__selection_preview" };
var cr = { class: "dp__action_buttons" };
var fr = ["onKeydown"];
var mr = defineComponent({
  __name: "ActionRow",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, ta), hn), ea), gn), la), {
    inline: { type: Boolean, default: false },
    timePicker: { type: Boolean, default: false },
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: false },
    enableTimePicker: { type: Boolean, default: true }
  }),
  emits: ["closePicker", "selectDate", "invalid-select"],
  setup(e, { emit: a }) {
    const n = e, { buildMatrix: t } = qe(), c = inject(Jn), m = inject(Xe), v = ref(null), y = ref(null);
    onMounted(() => {
      m != null && m.value && t([we(v), we(y)], "actionRow");
    });
    const h = computed(() => n.range && !n.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : true), M = computed(() => ({
      dp__action: true,
      dp__select: true,
      dp__action_disabled: !R.value || !B.value || !h.value
    })), R = computed(() => n.enableTimePicker ? on(n.internalModelValue, n.maxTime, n.minTime, n.maxDate, n.minDate) : true), B = computed(() => n.monthPicker ? Al(n.internalModelValue, n.minDate, n.maxDate) : true), Y = (T) => mt(T, n.previewFormat, c == null ? void 0 : c.value), O = computed(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? bt(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${Y(n.internalModelValue[0])} - ${Y(n.internalModelValue[1])}` : [Y(n.internalModelValue[0]), Y(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map((T) => `${Y(T)}`) : n.modelAuto ? `${Y(n.internalModelValue[0])}` : `${Y(n.internalModelValue[0])} -` : mt(n.internalModelValue, n.previewFormat, c == null ? void 0 : c.value) : n.timePicker ? n.previewFormat(sn(n.internalModelValue)) : n.monthPicker ? n.previewFormat(Nt(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), L = () => {
      R.value && B.value && h.value ? a("selectDate") : a("invalid-select");
    };
    return (T, te) => (openBlock(), createElementBlock("div", {
      class: "dp__action_row",
      style: normalizeStyle(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      createBaseVNode("div", dr, [
        T.$slots["action-preview"] ? renderSlot(T.$slots, "action-preview", {
          key: 0,
          value: T.internalModelValue
        }) : createCommentVNode("", true),
        T.$slots["action-preview"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          Array.isArray(unref(O)) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(unref(O)), 1)
          ], 64)),
          Array.isArray(unref(O)) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(O), (l, o) => (openBlock(), createElementBlock("div", { key: o }, toDisplayString(l), 1))), 128)) : createCommentVNode("", true)
        ], 64))
      ]),
      createBaseVNode("div", cr, [
        T.$slots["action-select"] ? renderSlot(T.$slots, "action-select", {
          key: 0,
          value: T.internalModelValue
        }) : createCommentVNode("", true),
        T.$slots["action-select"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          e.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", {
            key: 0,
            class: "dp__action dp__cancel",
            ref_key: "cancelButtonRef",
            ref: v,
            tabindex: "0",
            onClick: te[0] || (te[0] = (l) => T.$emit("closePicker")),
            onKeydown: te[1] || (te[1] = withKeys((l) => T.$emit("closePicker"), ["enter"]))
          }, toDisplayString(T.cancelText), 545)),
          createBaseVNode("span", {
            class: normalizeClass(unref(M)),
            tabindex: "0",
            onKeydown: withKeys(L, ["enter"]),
            onClick: L,
            ref_key: "selectButtonRef",
            ref: y
          }, toDisplayString(T.selectText), 43, fr)
        ], 64))
      ])
    ], 4));
  }
});
var vr = { class: "dp__selection_grid_header" };
var yr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var pr = ["aria-label", "onKeydown"];
var Dt = defineComponent({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: false },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: false },
    monthPicker: { type: Boolean, default: false },
    yearPicker: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "selected", "toggle", "reset-flow"],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = ref(false), m = ref(null), v = ref(null), y = ref([]), h = inject(vn, false), M = inject(qn, ref(false)), R = inject(ze), B = inject(Xe), Y = ref(), O = ref(), { setSelectionGrid: L, buildMultiLevelMatrix: T, setMonthPicker: te } = qe();
    onBeforeUpdate(() => {
      m.value = null;
    }), onMounted(() => {
      nextTick().then(() => Q()), o(), l(true);
    }), onUnmounted(() => l(false));
    const l = (s) => {
      var w;
      B != null && B.value && ((w = t.headerRefs) != null && w.length ? te(s) : L(s));
    }, o = () => {
      const s = we(v);
      s && (M.value || s.focus({ preventScroll: true }), c.value = s.clientHeight < s.scrollHeight);
    }, F = computed(() => ({
      dp__overlay: true
    })), J = computed(() => ({
      dp__overlay_col: true
    })), _ = computed(() => t.items.map((s) => s.filter((w) => w).map((w) => {
      var I, re, p;
      const E = t.disabledValues.some((P) => P === w.value) || Z(w.value), ee = (I = t.multiModelValue) != null && I.length ? (re = t.multiModelValue) == null ? void 0 : re.some((P) => ue(P, setYear(t.monthPicker ? setMonth(new Date(), w.value) : new Date(), t.monthPicker ? t.year : w.value))) : t.skipActive ? false : w.value === t.modelValue;
      return __spreadProps(__spreadValues({}, w), {
        className: {
          dp__overlay_cell_active: ee,
          dp__overlay_cell: !ee,
          dp__overlay_cell_disabled: E,
          dp__overlay_cell_active_disabled: E && ee,
          dp__overlay_cell_pad: true,
          dp__cell_in_between: (p = t.multiModelValue) != null && p.length ? D(w.value) : false
        }
      });
    }))), U = computed(() => ({
      dp__button: true,
      dp__overlay_action: true,
      dp__over_action_scroll: c.value,
      dp__button_bottom: h
    })), z = computed(() => {
      var s, w;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((s = t.items) == null ? void 0 : s.length) <= 6,
        dp__container_block: ((w = t.items) == null ? void 0 : w.length) > 6
      };
    }), Z = (s) => {
      const w = t.maxValue || t.maxValue === 0, E = t.minValue || t.minValue === 0;
      return !w && !E ? false : w && E ? +s > +t.maxValue || +s < +t.minValue : w ? +s > +t.maxValue : E ? +s < +t.minValue : false;
    }, Q = () => {
      const s = we(m);
      if (s) {
        const w = we(v);
        w && (w.scrollTop = s.offsetTop - w.offsetTop - (w.getBoundingClientRect().height / 2 - s.getBoundingClientRect().height));
      }
    }, j = (s) => {
      !t.disabledValues.some((w) => w === s) && !Z(s) && (n("update:modelValue", s), n("selected"));
    }, D = (s) => {
      const w = t.monthPicker ? t.year : s;
      return jn(t.multiModelValue, setYear(t.monthPicker ? setMonth(new Date(), Y.value || 0) : new Date(), t.monthPicker ? w : Y.value || w), setYear(t.monthPicker ? setMonth(new Date(), s) : new Date(), w));
    }, $ = () => {
      n("toggle"), n("reset-flow");
    }, i = (s, w, E, ee) => {
      var I, re;
      if (s && (w.value === +t.modelValue && !t.disabledValues.includes(w.value) && (m.value = s), B != null && B.value)) {
        Array.isArray(y.value[E]) ? y.value[E][ee] = s : y.value[E] = [s];
        const p = (I = t.headerRefs) != null && I.length ? [t.headerRefs].concat(y.value) : y.value.concat([t.skipButtonRef ? [] : [O.value]]);
        T(p, (re = t.headerRefs) != null && re.length ? "monthPicker" : "selectionGrid");
      }
    };
    return a({ focusGrid: o }), (s, w) => (openBlock(), createElementBlock("div", {
      ref_key: "gridWrapRef",
      ref: v,
      class: normalizeClass(unref(F)),
      role: "dialog",
      tabindex: "0"
    }, [
      createBaseVNode("div", {
        class: normalizeClass(unref(z)),
        role: "grid"
      }, [
        createBaseVNode("div", vr, [
          renderSlot(s.$slots, "header")
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(_), (E, ee) => (openBlock(), createElementBlock("div", {
          class: "dp__overlay_row",
          key: unref(Ll)(ee),
          role: "row"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(E, (I, re) => (openBlock(), createElementBlock("div", {
            role: "gridcell",
            class: normalizeClass(unref(J)),
            key: I.value,
            "aria-selected": I.value === e.modelValue && !e.disabledValues.includes(I.value),
            "aria-disabled": I.className.dp__overlay_cell_disabled,
            ref_for: true,
            ref: (p) => i(p, I, ee, re),
            tabindex: "0",
            onClick: (p) => j(I.value),
            onKeydown: withKeys((p) => j(I.value), ["enter"]),
            onMouseover: (p) => Y.value = I.value
          }, [
            createBaseVNode("div", {
              class: normalizeClass(I.className)
            }, [
              s.$slots.item ? renderSlot(s.$slots, "item", {
                key: 0,
                item: I
              }) : createCommentVNode("", true),
              s.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(I.text), 1)
              ], 64))
            ], 2)
          ], 42, yr))), 128))
        ]))), 128)),
        s.$slots["button-icon"] ? (openBlock(), createElementBlock("div", {
          key: 0,
          role: "button",
          "aria-label": unref(R).toggleOverlay,
          class: normalizeClass(unref(U)),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: O,
          onClick: $,
          onKeydown: withKeys($, ["enter"])
        }, [
          renderSlot(s.$slots, "button-icon")
        ], 42, pr)) : createCommentVNode("", true)
      ], 2)
    ], 2));
  }
});
var Ut = () => {
  const e = inject(Wt);
  return { transitionName: computed(() => (n) => e != null && e.value ? n ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
};
var hr = {
  key: 0,
  class: "dp__time_input"
};
var gr = createTextVNode(" : ");
var wr = ["aria-label", "onKeydown", "onClick"];
var kr = ["aria-label", "onKeydown", "onClick"];
var br = ["aria-label", "onKeydown", "onClick"];
var $r = { key: 0 };
var Dr = ["aria-label", "onKeydown"];
var Mr = defineComponent({
  __name: "TimeInput",
  props: __spreadProps(__spreadValues({}, Zn), {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    filters: { type: Object, default: () => ({}) },
    disabled: { type: Boolean, default: false },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 }
  }),
  emits: [
    "setHours",
    "setMinutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = reactive({
      hours: false,
      minutes: false,
      seconds: false
    }), m = ref("AM"), v = ref(null), y = inject(ze), h = inject(Xe), M = ref([]), { transitionName: R, showTransition: B } = Ut(), { setTimePickerElements: Y, setTimePickerBackRef: O } = qe();
    onMounted(() => {
      n("mounted");
    });
    const L = computed(() => ({
      dp__time_col: true,
      dp__time_col_reg: !t.enableSeconds && t.is24,
      dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
      dp__time_col_sec: t.enableSeconds && t.is24,
      dp__time_col_sec_with_button: t.enableSeconds && !t.is24
    })), T = computed(() => {
      const D = [{ type: "hours" }, "separator", { type: "minutes" }];
      return t.enableSeconds ? D.concat(["separator", { type: "seconds" }]) : D;
    }), te = computed(() => T.value.filter((D) => typeof D != "string")), l = computed(() => (D) => {
      if (D === "hours") {
        const $ = U(t.hours);
        return { text: $ < 10 ? `0${$}` : `${$}`, value: $ };
      }
      return { text: t[D] < 10 ? `0${t[D]}` : `${t[D]}`, value: t[D] };
    }), o = (D) => {
      const $ = D === "hours" ? t.is24 ? 24 : 12 : 60, i = +t[`${D}GridIncrement`], s = [];
      for (let w = 0; w < $; w += i)
        s.push({ value: w, text: w < 10 ? `0${w}` : `${w}` });
      return Yl(s);
    }, F = (D) => t[`no${D[0].toUpperCase() + D.slice(1)}Overlay`], J = (D) => {
      F(D) || (c[D] = !c[D], c[D] || n("overlay-closed"));
    }, _ = (D, $ = true) => {
      const i = D === "hours" ? getHours : D === "minutes" ? getMinutes : getSeconds, s = $ ? Ml : Sl;
      n(`update:${D}`, i(s({ [D]: +t[D] }, { [D]: +t[`${D}Increment`] })));
    }, U = (D) => t.is24 ? D : (D >= 12 ? m.value = "PM" : m.value = "AM", Hl(D)), z = () => {
      m.value === "PM" ? (m.value = "AM", n("update:hours", t.hours - 12)) : (m.value = "PM", n("update:hours", t.hours + 12));
    }, Z = (D) => {
      c[D] = true;
    }, Q = (D, $, i) => {
      if (D && (h == null ? void 0 : h.value)) {
        Array.isArray(M.value[$]) ? M.value[$][i] = D : M.value[$] = [D];
        const s = M.value.reduce((w, E) => E.map((ee, I) => [...w[I] || [], E[I]]), []);
        O(t.closeTimePickerBtn), v.value && (s[1] = s[1].concat(v.value)), Y(s, t.order);
      }
    }, j = (D, $) => D === "hours" && !t.is24 ? n(`update:${D}`, m.value === "PM" ? $ + 12 : $) : n(`update:${D}`, $);
    return a({ openChildCmp: Z }), (D, $) => e.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", hr, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(T), (i, s) => (openBlock(), createElementBlock("div", {
        key: s,
        class: normalizeClass(unref(L))
      }, [
        i === "separator" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          gr
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": unref(y).incrementValue(i.type),
            tabindex: "0",
            onKeydown: withKeys((w) => _(i.type), ["enter"]),
            onClick: (w) => _(i.type),
            ref_for: true,
            ref: (w) => Q(w, s, 0)
          }, [
            D.$slots["arrow-up"] ? renderSlot(D.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
            D.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Un), { key: 1 }))
          ], 40, wr),
          createBaseVNode("div", {
            role: "button",
            "aria-label": unref(y).openTpOverlay(i.type),
            class: normalizeClass(F(i.type) ? "" : "dp__time_display"),
            tabindex: "0",
            onKeydown: withKeys((w) => J(i.type), ["enter"]),
            onClick: (w) => J(i.type),
            ref_for: true,
            ref: (w) => Q(w, s, 1)
          }, [
            D.$slots[i.type] ? renderSlot(D.$slots, i.type, {
              key: 0,
              text: unref(l)(i.type).text,
              value: unref(l)(i.type).value
            }) : createCommentVNode("", true),
            D.$slots[i.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(unref(l)(i.type).text), 1)
            ], 64))
          ], 42, kr),
          createBaseVNode("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": unref(y).decrementValue(i.type),
            tabindex: "0",
            onKeydown: withKeys((w) => _(i.type, false), ["enter"]),
            onClick: (w) => _(i.type, false),
            ref_for: true,
            ref: (w) => Q(w, s, 2)
          }, [
            D.$slots["arrow-down"] ? renderSlot(D.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
            D.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ln), { key: 1 }))
          ], 40, br)
        ], 64))
      ], 2))), 128)),
      D.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", $r, [
        D.$slots["am-pm-button"] ? renderSlot(D.$slots, "am-pm-button", {
          key: 0,
          toggle: z,
          value: m.value
        }) : createCommentVNode("", true),
        D.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: v,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": unref(y).amPmButton,
          tabindex: "0",
          onClick: z,
          onKeydown: withKeys(withModifiers(z, ["prevent"]), ["enter"])
        }, toDisplayString(m.value), 41, Dr))
      ])),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(te), (i, s) => (openBlock(), createBlock(Transition, {
        key: s,
        name: unref(R)(c[i.type]),
        css: unref(B)
      }, {
        default: withCtx(() => [
          c[i.type] ? (openBlock(), createBlock(Dt, {
            key: 0,
            items: o(i.type),
            "disabled-values": e.filters.times[i.type],
            "onUpdate:modelValue": (w) => j(i.type, w),
            onSelected: (w) => J(i.type),
            onToggle: (w) => J(i.type),
            onResetFlow: $[0] || ($[0] = (w) => D.$emit("reset-flow"))
          }, createSlots({
            "button-icon": withCtx(() => [
              D.$slots["clock-icon"] ? renderSlot(D.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
              D.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wn), { key: 1 }))
            ]),
            _: 2
          }, [
            D.$slots[`${i.type}-overlay`] ? {
              name: "item",
              fn: withCtx(({ item: w }) => [
                renderSlot(D.$slots, `${i.type}-overlay`, {
                  text: w.text,
                  value: w.value
                })
              ])
            } : void 0
          ]), 1032, ["items", "disabled-values", "onUpdate:modelValue", "onSelected", "onToggle"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, 1032, ["name", "css"]))), 128))
    ]));
  }
});
var kt = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["calendar", "month-year"] },
  { name: "hours-overlay", use: ["calendar", "time"] },
  { name: "minutes-overlay", use: ["calendar", "time"] },
  { name: "seconds-overlay", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] }
];
var Sr = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
var Ar = {
  all: () => kt,
  monthYear: () => kt.filter((e) => e.use.includes("month-year")),
  input: () => Sr,
  timePicker: () => kt.filter((e) => e.use.includes("time")),
  action: () => kt.filter((e) => e.use.includes("action")),
  calendar: () => kt.filter((e) => e.use.includes("calendar"))
};
var at = (e, a) => {
  const n = [];
  return Ar[a]().forEach((t) => {
    e[t.name] && n.push(t.name);
  }), n;
};
var Pr = ["aria-label"];
var Cr = { class: "dp__overlay_container dp__container_flex" };
var Tr = {
  key: 1,
  class: "dp__overlay_row"
};
var _r = ["aria-label"];
var Rr = defineComponent({
  __name: "TimePicker",
  props: __spreadProps(__spreadValues({}, Qn), {
    range: { type: Boolean, default: false },
    filters: { type: Object, default: () => ({}) },
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    customProps: { type: Object, default: null },
    modelAuto: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null }
  }),
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = useSlots(), m = ref(null), v = ref(null), y = inject(vn, false), h = ref([]), M = ref(null), R = inject(ze), B = inject(Xe), { transitionName: Y, showTransition: O } = Ut(), { buildMatrix: L, setTimePicker: T } = qe();
    onMounted(() => {
      n("mount"), !t.timePicker && (B == null ? void 0 : B.value) ? L([we(m.value)], "time") : T(true, t.timePicker);
    });
    const te = computed(() => t.range && t.modelAuto ? sa(t.internalModelValue) : true), l = ref(false), o = ($) => ({
      hours: Array.isArray(t.hours) ? t.hours[$] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[$] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[$] : t.seconds
    }), F = computed(() => {
      const $ = [];
      if (t.range)
        for (let i = 0; i < 2; i++)
          $.push(o(i));
      else
        $.push(o(0));
      return $;
    }), J = ($, i = false, s = "") => {
      i || n("reset-flow"), l.value = $, B != null && B.value && (T($), $ || n("overlay-closed")), nextTick(() => {
        s !== "" && h.value[0] && h.value[0].openChildCmp(s);
      });
    }, _ = computed(() => ({
      dp__button: true,
      dp__button_bottom: y
    })), U = at(c, "timePicker"), z = ($, i, s) => t.range ? i === 0 ? [$, F.value[1][s]] : [F.value[0][s], $] : $, Z = ($) => {
      n("update:hours", $);
    }, Q = ($) => {
      n("update:minutes", $);
    }, j = ($) => {
      n("update:seconds", $);
    }, D = () => {
      M.value && (B == null ? void 0 : B.value) && M.value.focus({ preventScroll: true });
    };
    return a({ toggleTimePicker: J }), ($, i) => (openBlock(), createElementBlock("div", null, [
      $.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(unref(_)),
        role: "button",
        "aria-label": unref(R).openTimePicker,
        tabindex: "0",
        ref_key: "openTimePickerBtn",
        ref: m,
        onKeydown: i[0] || (i[0] = withKeys((s) => J(true), ["enter"])),
        onClick: i[1] || (i[1] = (s) => J(true))
      }, [
        $.$slots["clock-icon"] ? renderSlot($.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
        $.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wn), { key: 1 }))
      ], 42, Pr)),
      createVNode(Transition, {
        name: unref(Y)(l.value),
        css: unref(O)
      }, {
        default: withCtx(() => [
          l.value || $.timePicker ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "dp__overlay",
            ref_key: "overlayRef",
            ref: M,
            tabindex: "0"
          }, [
            createBaseVNode("div", Cr, [
              $.$slots["time-picker-overlay"] ? renderSlot($.$slots, "time-picker-overlay", {
                key: 0,
                range: e.range,
                hours: e.hours,
                minutes: e.minutes,
                seconds: e.seconds,
                setHours: Z,
                setMinutes: Q,
                setSeconds: j
              }) : createCommentVNode("", true),
              $.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Tr, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(F), (s, w) => withDirectives((openBlock(), createBlock(Mr, mergeProps({
                  key: w,
                  disabled: w === 0 ? $.fixedStart : $.fixedEnd,
                  hours: s.hours,
                  minutes: s.minutes,
                  seconds: s.seconds,
                  filters: e.filters,
                  ref_for: true,
                  ref_key: "timeInputRefs",
                  ref: h
                }, {
                  is24: $.is24,
                  hoursGridIncrement: $.hoursGridIncrement,
                  minutesGridIncrement: $.minutesGridIncrement,
                  secondsGridIncrement: $.secondsGridIncrement,
                  hoursIncrement: $.hoursIncrement,
                  minutesIncrement: $.minutesIncrement,
                  secondsIncrement: $.secondsIncrement,
                  filters: e.filters,
                  noHoursOverlay: $.noHoursOverlay,
                  noMinutesOverlay: $.noMinutesOverlay,
                  noSecondsOverlay: $.noSecondsOverlay,
                  enableSeconds: $.enableSeconds,
                  closeTimePickerBtn: v.value,
                  order: w
                }, {
                  "onUpdate:hours": (E) => Z(z(E, w, "hours")),
                  "onUpdate:minutes": (E) => Q(z(E, w, "minutes")),
                  "onUpdate:seconds": (E) => j(z(E, w, "seconds")),
                  onMounted: D,
                  onOverlayClosed: D
                }), createSlots({ _: 2 }, [
                  renderList(unref(U), (E, ee) => ({
                    name: E,
                    fn: withCtx((I) => [
                      renderSlot($.$slots, E, normalizeProps(guardReactiveProps(I)))
                    ])
                  }))
                ]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                  [vShow, w === 0 ? true : unref(te)]
                ])), 128))
              ])),
              $.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                key: 2,
                ref_key: "closeTimePickerBtn",
                ref: v,
                class: normalizeClass(unref(_)),
                role: "button",
                "aria-label": unref(R).closeTimePicker,
                tabindex: "0",
                onKeydown: i[2] || (i[2] = withKeys((s) => J(false), ["enter"])),
                onClick: i[3] || (i[3] = (s) => J(false))
              }, [
                $.$slots["calendar-icon"] ? renderSlot($.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                $.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ht), { key: 1 }))
              ], 42, _r))
            ])
          ], 512)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ]));
  }
});
var Vr = ["aria-label"];
var nn = defineComponent({
  __name: "ActionIcon",
  props: { ariaLabel: { type: String, default: "" } },
  emits: ["activate", "setRef"],
  setup(e, { emit: a }) {
    const n = ref(null);
    return onMounted(() => a("setRef", n)), (t, c) => (openBlock(), createElementBlock("div", {
      class: "dp__month_year_col_nav",
      onClick: c[0] || (c[0] = (m) => t.$emit("activate")),
      onKeydown: c[1] || (c[1] = withKeys((m) => t.$emit("activate"), ["enter"])),
      tabindex: "0",
      ref_key: "elRef",
      ref: n
    }, [
      createBaseVNode("div", {
        class: "dp__inner_nav",
        role: "button",
        "aria-label": e.ariaLabel
      }, [
        renderSlot(t.$slots, "default")
      ], 8, Vr)
    ], 544));
  }
});
var Br = ["aria-label"];
var Bn = defineComponent({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: false },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "setRef"],
  setup(e, { emit: a }) {
    const { transitionName: n, showTransition: t } = Ut(), c = ref(null);
    return onMounted(() => a("setRef", c)), (m, v) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        class: "dp__month_year_select",
        onClick: v[0] || (v[0] = (y) => m.$emit("toggle")),
        onKeydown: v[1] || (v[1] = withKeys((y) => m.$emit("toggle"), ["enter"])),
        role: "button",
        "aria-label": e.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: c
      }, [
        renderSlot(m.$slots, "default")
      ], 40, Br),
      createVNode(Transition, {
        name: unref(n)(e.showSelectionGrid),
        css: unref(t)
      }, {
        default: withCtx(() => [
          e.showSelectionGrid ? (openBlock(), createBlock(Dt, mergeProps({ key: 0 }, {
            modelValue: e.modelValue,
            items: e.items,
            disabledValues: e.disabledValues,
            minValue: e.minValue,
            maxValue: e.maxValue
          }, {
            "header-refs": [],
            "onUpdate:modelValue": v[2] || (v[2] = (y) => m.$emit("update:model-value", y)),
            onToggle: v[3] || (v[3] = (y) => m.$emit("toggle"))
          }), createSlots({
            "button-icon": withCtx(() => [
              m.$slots["calendar-icon"] ? renderSlot(m.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
              m.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ht), { key: 1 }))
            ]),
            _: 2
          }, [
            m.$slots[e.slotName] ? {
              name: "item",
              fn: withCtx(({ item: y }) => [
                renderSlot(m.$slots, e.slotName, { item: y })
              ])
            } : void 0
          ]), 1040)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
});
var Ft = (e, a, n) => [set(new Date(e), { date: 1 }), set(new Date(), { month: a, year: n, date: 1 })];
var On = (e, a, n) => ke(...Ft(e, a, n)) || ue(...Ft(e, a, n));
var Nn = (e, a, n) => De(...Ft(e, a, n)) || ue(...Ft(e, a, n));
var oa = (e, a, n, t, c, m) => {
  let v = false;
  return m ? e && a ? (a && c && Nn(a, n, t) && (v = true), e && !c && On(e, n, t) && (v = true)) : (e && On(e, n, t) || a && Nn(a, n, t)) && (v = true) : v = true, v;
};
var Or = (e, a) => {
  const n = (v, y) => {
    let h = v;
    return e.filters.months.includes(getMonth(h)) ? (h = y ? addMonths(v, 1) : subMonths(v, 1), n(h, y)) : h;
  }, t = (v, y) => {
    let h = v;
    return e.filters.years.includes(getYear(h)) ? (h = y ? addYears(v, 1) : subYears(v, 1), t(h, y)) : h;
  }, c = (v) => {
    const y = set(new Date(), { month: e.month, year: e.year });
    let h = v ? addMonths(y, 1) : subMonths(y, 1), M = getMonth(h), R = getYear(h);
    e.filters.months.includes(M) && (h = n(h, v), M = getMonth(h), R = getYear(h)), e.filters.years.includes(R) && (h = t(h, v), R = getYear(h)), oa(e.minDate, e.maxDate, M, R, v, e.preventMinMaxNavigation) && m(M, R);
  }, m = (v, y) => {
    a("update-month-year", { month: v, year: y });
  };
  return { handleMonthYearChange: c };
};
var Nr = { class: "dp__month_year_row" };
var Ir = { class: "dp__month_picker_header" };
var Yr = ["aria-label"];
var Er = ["aria-label", "onKeydown"];
var Fr = ["aria-label"];
var Kr = defineComponent({
  __name: "MonthYearPicker",
  props: __spreadProps(__spreadValues(__spreadValues({}, ra), hn), {
    preventMinMaxNavigation: { type: Boolean, default: false },
    reverseYears: { type: Boolean, default: false },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    filters: { type: Object, default: () => ({}) },
    multiCalendarsSolo: { type: Boolean, default: false },
    yearPicker: { type: Boolean, default: false }
  }),
  emits: ["update-month-year", "monthYearSelect", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: a, emit: n }) {
    const t = e, { transitionName: c, showTransition: m } = Ut(), { buildMatrix: v } = qe(), y = ref(false), h = ref(false), M = ref([null, null, null, null]), R = ref(null), B = ref(null), Y = ref(null), O = inject(ze), L = inject(Xe), { handleMonthYearChange: T } = Or(t, n);
    onMounted(() => {
      n("mount");
    });
    const te = (p) => ({
      get: () => t[p],
      set: (P) => {
        const N = p === "month" ? "year" : "month";
        n("update-month-year", { [p]: P, [N]: t[N] }), n("monthYearSelect", p === "year"), p === "month" ? w(true) : E(true);
      }
    }), l = computed(te("month")), o = computed(te("year")), F = computed(() => (p) => {
      const P = p === "month";
      return {
        showSelectionGrid: (P ? y : h).value,
        items: (P ? D : $).value,
        disabledValues: t.filters[P ? "months" : "years"],
        minValue: (P ? U : J).value,
        maxValue: (P ? z : _).value,
        headerRefs: P && t.monthPicker ? [R.value, B.value, Y.value] : []
      };
    }), J = computed(() => t.minDate ? getYear(new Date(t.minDate)) : null), _ = computed(() => t.maxDate ? getYear(new Date(t.maxDate)) : null), U = computed(() => {
      if (t.minDate && J.value) {
        if (J.value > t.year)
          return 12;
        if (J.value === t.year)
          return getMonth(new Date(t.minDate));
      }
      return null;
    }), z = computed(() => t.maxDate && _.value ? _.value < t.year ? -1 : _.value === t.year ? getMonth(new Date(t.maxDate)) : null : null), Z = computed(() => t.range && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), Q = (p, P = false) => {
      const N = [];
      for (let pe = 0; pe < p.length; pe += 3) {
        const Ee = [p[pe], p[pe + 1], p[pe + 2]];
        N.push(P ? Ee.reverse() : Ee);
      }
      return P ? N.reverse() : N;
    }, j = computed(() => {
      const p = t.months.find((P) => P.value === t.month);
      return p || { text: "", value: 0 };
    }), D = computed(() => Q(t.months)), $ = computed(() => Q(t.years, t.reverseYears)), i = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === 0 : true), s = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === t.multiCalendars - 1 : true), w = (p = false) => {
      ee(p), y.value = !y.value, y.value || n("overlay-closed");
    }, E = (p = false) => {
      ee(p), h.value = !h.value, h.value || n("overlay-closed");
    }, ee = (p) => {
      p || n("reset-flow");
    }, I = (p = false) => {
      n("update-month-year", { year: p ? t.year + 1 : t.year - 1, month: t.month });
    }, re = (p, P) => {
      L != null && L.value && (M.value[P] = we(p), v(M.value, "monthYear"));
    };
    return a({
      toggleMonthPicker: w,
      toggleYearPicker: E
    }), (p, P) => (openBlock(), createElementBlock("div", Nr, [
      !p.monthPicker && !e.yearPicker ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        unref(i) && !p.vertical ? (openBlock(), createBlock(nn, {
          key: 0,
          "aria-label": unref(O).prevMonth,
          onActivate: P[0] || (P[0] = (N) => unref(T)(false)),
          onSetRef: P[1] || (P[1] = (N) => re(N, 0))
        }, {
          default: withCtx(() => [
            p.$slots["arrow-left"] ? renderSlot(p.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
            p.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Mn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label"])) : createCommentVNode("", true),
        createVNode(Bn, mergeProps({
          "aria-label": unref(O).openMonthsOverlay,
          "slot-name": "month-overlay",
          modelValue: unref(l),
          "onUpdate:modelValue": P[2] || (P[2] = (N) => isRef(l) ? l.value = N : null)
        }, unref(F)("month"), {
          onToggle: w,
          onSetRef: P[3] || (P[3] = (N) => re(N, 1))
        }), createSlots({
          default: withCtx(() => [
            p.$slots.month ? renderSlot(p.$slots, "month", normalizeProps(mergeProps({ key: 0 }, unref(j)))) : createCommentVNode("", true),
            p.$slots.month ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(unref(j).text), 1)
            ], 64))
          ]),
          _: 2
        }, [
          p.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: withCtx(() => [
              renderSlot(p.$slots, "calendar-icon")
            ])
          } : void 0,
          p.$slots["month-overlay"] ? {
            name: "month-overlay",
            fn: withCtx(({ item: N }) => [
              renderSlot(p.$slots, "month-overlay", {
                text: N.text,
                value: N.value
              })
            ])
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        createVNode(Bn, mergeProps({
          "aria-label": unref(O).openYearsOverlay,
          "slot-name": "year-overlay",
          modelValue: unref(o),
          "onUpdate:modelValue": P[4] || (P[4] = (N) => isRef(o) ? o.value = N : null)
        }, unref(F)("year"), {
          onToggle: E,
          onSetRef: P[5] || (P[5] = (N) => re(N, 2))
        }), createSlots({
          default: withCtx(() => [
            p.$slots.year ? renderSlot(p.$slots, "year", {
              key: 0,
              year: p.year
            }) : createCommentVNode("", true),
            p.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(p.year), 1)
            ], 64))
          ]),
          _: 2
        }, [
          p.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: withCtx(() => [
              renderSlot(p.$slots, "calendar-icon")
            ])
          } : void 0,
          p.$slots["year-overlay"] ? {
            name: "year-overlay",
            fn: withCtx(({ item: N }) => [
              renderSlot(p.$slots, "year-overlay", {
                text: N.text,
                value: N.value
              })
            ])
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        unref(i) && p.vertical ? (openBlock(), createBlock(nn, {
          key: 1,
          "aria-label": unref(O).prevMonth,
          onActivate: P[6] || (P[6] = (N) => unref(T)(false))
        }, {
          default: withCtx(() => [
            p.$slots["arrow-up"] ? renderSlot(p.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
            p.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Un), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label"])) : createCommentVNode("", true),
        unref(s) ? (openBlock(), createBlock(nn, {
          key: 2,
          "arial-label": unref(O).nextMonth,
          onActivate: P[7] || (P[7] = (N) => unref(T)(true)),
          ref: "rightIcon",
          onSetRef: P[8] || (P[8] = (N) => re(N, 3))
        }, {
          default: withCtx(() => [
            p.$slots[p.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(p.$slots, p.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
            p.$slots[p.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(p.vertical ? unref(Ln) : unref(Sn)), { key: 1 }))
          ]),
          _: 3
        }, 8, ["arial-label"])) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      p.monthPicker ? (openBlock(), createBlock(Dt, mergeProps({ key: 1 }, unref(F)("month"), {
        "skip-active": t.range,
        year: p.year,
        "multi-model-value": unref(Z),
        "month-picker": "",
        modelValue: unref(l),
        "onUpdate:modelValue": P[15] || (P[15] = (N) => isRef(l) ? l.value = N : null),
        onToggle: w,
        onSelected: P[16] || (P[16] = (N) => p.$emit("overlay-closed"))
      }), createSlots({
        header: withCtx(() => [
          createBaseVNode("div", Ir, [
            createBaseVNode("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpPrevIconRef",
              ref: R,
              onClick: P[9] || (P[9] = (N) => I(false)),
              onKeydown: P[10] || (P[10] = withKeys((N) => I(false), ["enter"]))
            }, [
              createBaseVNode("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": unref(O).prevMonth
              }, [
                p.$slots["arrow-left"] ? renderSlot(p.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                p.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Mn), { key: 1 }))
              ], 8, Yr)
            ], 544),
            createBaseVNode("div", {
              class: "dp__pointer",
              role: "button",
              ref_key: "mpYearButtonRef",
              ref: B,
              "aria-label": unref(O).openYearsOverlay,
              tabindex: "0",
              onClick: E,
              onKeydown: withKeys(E, ["enter"])
            }, [
              p.$slots.year ? renderSlot(p.$slots, "year", {
                key: 0,
                year: p.year
              }) : createCommentVNode("", true),
              p.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(p.year), 1)
              ], 64))
            ], 40, Er),
            createBaseVNode("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpNextIconRef",
              ref: Y,
              onClick: P[11] || (P[11] = (N) => I(true)),
              onKeydown: P[12] || (P[12] = withKeys((N) => I(true), ["enter"]))
            }, [
              createBaseVNode("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": unref(O).nextMonth
              }, [
                p.$slots["arrow-right"] ? renderSlot(p.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
                p.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Sn), { key: 1 }))
              ], 8, Fr)
            ], 544)
          ]),
          createVNode(Transition, {
            name: unref(c)(h.value),
            css: unref(m)
          }, {
            default: withCtx(() => [
              h.value ? (openBlock(), createBlock(Dt, mergeProps({ key: 0 }, unref(F)("year"), {
                modelValue: unref(o),
                "onUpdate:modelValue": P[13] || (P[13] = (N) => isRef(o) ? o.value = N : null),
                onToggle: E,
                onSelected: P[14] || (P[14] = (N) => p.$emit("overlay-closed"))
              }), createSlots({
                "button-icon": withCtx(() => [
                  p.$slots["calendar-icon"] ? renderSlot(p.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                  p.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ht), { key: 1 }))
                ]),
                _: 2
              }, [
                p.$slots["year-overlay"] ? {
                  name: "item",
                  fn: withCtx(({ item: N }) => [
                    renderSlot(p.$slots, "year-overlay", {
                      text: N.text,
                      value: N.value
                    })
                  ])
                } : void 0
              ]), 1040, ["modelValue"])) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 2
      }, [
        p.$slots["month-overlay"] ? {
          name: "item",
          fn: withCtx(({ item: N }) => [
            renderSlot(p.$slots, "month-overlay", {
              text: N.text,
              value: N.value
            })
          ])
        } : void 0
      ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : createCommentVNode("", true),
      e.yearPicker ? (openBlock(), createBlock(Dt, mergeProps({ key: 2 }, unref(F)("year"), {
        modelValue: unref(o),
        "onUpdate:modelValue": P[17] || (P[17] = (N) => isRef(o) ? o.value = N : null),
        "multi-model-value": unref(Z),
        "skip-active": t.range,
        "skip-button-ref": "",
        "year-picker": "",
        onToggle: E,
        onSelected: P[18] || (P[18] = (N) => p.$emit("overlay-closed"))
      }), createSlots({ _: 2 }, [
        p.$slots["year-overlay"] ? {
          name: "item",
          fn: withCtx(({ item: N }) => [
            renderSlot(p.$slots, "year-overlay", {
              text: N.text,
              value: N.value
            })
          ])
        } : void 0
      ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : createCommentVNode("", true)
    ]));
  }
});
var Hr = (e, a, n, t) => {
  const c = ref(new Date()), m = ref(), v = ref([{ month: getMonth(new Date()), year: getYear(new Date()) }]), y = ref(e.range ? [getHours(new Date()), getHours(new Date())] : getHours(new Date())), h = ref(e.range ? [getMinutes(new Date()), getMinutes(new Date())] : getMinutes(new Date())), M = ref(e.range ? [0, 0] : 0);
  watch(v, () => {
    setTimeout(() => {
      e.openOnTop && a("dpOpen");
    }, 0);
  }, { deep: true }), onMounted(() => {
    Q(true), l.value || (e.startDate && (v.value[0].month = getMonth(new Date(e.startDate)), v.value[0].year = getYear(new Date(e.startDate)), e.multiCalendars && N(0)), e.startTime && te());
  });
  const R = computed(() => (r) => v.value[r] ? v.value[r].month : 0), B = computed(() => (r) => v.value[r] ? v.value[r].year : 0), Y = (r, k, A) => {
    v.value[r].month = k, v.value[r].year = A;
  }, O = (r, k) => v.value[r].month = k, L = (r, k) => v.value[r].year = k, T = (r = true) => e.enableSeconds ? Array.isArray(M.value) ? r ? M.value[0] : M.value[1] : M.value : 0, te = () => {
    e.startTime && (ur(e.startTime) ? (y.value = [+e.startTime[0].hours, +e.startTime[1].hours], h.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (M.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (y.value = +e.startTime.hours, h.value = +e.startTime.minutes, e.enableSeconds && (M.value = +e.startTime.seconds)));
  }, l = computed({
    get: () => e.internalModelValue,
    set: (r) => {
      !e.readonly && !e.disabled && a("update:internalModelValue", r);
    }
  });
  watch(l, () => Q());
  const o = (r) => {
    const { validate: k } = Xn(e.minDate, e.maxDate, e.disabledDates, e.allowedDates, e.filters, e.disabledWeekDays, e.yearRange);
    return !k(r);
  }, F = (r) => !l.value || e.hideOffsetDates && !r.current ? false : e.range ? e.modelAuto && Array.isArray(l.value) ? ue(r.value, l.value[0] ? l.value[0] : c.value) : false : e.multiDates && Array.isArray(l.value) ? l.value.some((k) => ue(k, r.value)) : ue(r.value, l.value ? l.value : c.value), J = (r) => jn(l.value, m.value, r.value), _ = (r, k = false) => {
    if ((!e.multiCalendars || !e.multiStatic || k) && (O(0, getMonth(r)), L(0, getYear(r))), e.multiCalendars)
      for (let A = 1; A <= e.multiCalendars; A++) {
        const X = set(new Date(), { month: R.value(A - 1), year: B.value(A - 1) }), Me = add(X, { months: 1 });
        v.value[A] = { month: getMonth(Me), year: getYear(Me) };
      }
  }, U = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const r = new Date(l.value[1] ? l.value[1] : addMonths(l.value[0], 1)), [k, A] = [getMonth(l.value[0]), getYear(l.value[0])], [X, Me] = [getMonth(l.value[1]), getYear(l.value[1])];
      (k !== X || k === X && A !== Me) && e.multiCalendarsSolo && (O(1, getMonth(r)), L(1, getYear(r)));
    }
  }, z = (r) => {
    _(r), y.value = getHours(r), h.value = getMinutes(r), M.value = getSeconds(r);
  }, Z = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null, Q = (r = false) => {
    if (l.value)
      if (bt(l.value)) {
        if (l.value.length === 2 && !e.multiDates)
          _(l.value[0], r), y.value = [
            getHours(l.value[0]),
            l.value[1] ? getHours(l.value[1]) : getHours(new Date())
          ], h.value = [
            getMinutes(l.value[0]),
            l.value[1] ? getMinutes(l.value[1]) : getMinutes(new Date())
          ], M.value = [
            getSeconds(l.value[0]),
            l.value[1] ? getSeconds(l.value[1]) : getSeconds(new Date())
          ];
        else if (bt(l.value) && e.multiDates) {
          const k = l.value[l.value.length - 1];
          k && z(k);
        }
        e.multiCalendars && e.multiCalendarsSolo && U();
      } else
        z(l.value);
    else
      e.timePicker ? (te(), e.range ? _e(y.value) && _e(h.value) && (l.value = [
        Se(new Date(), y.value[0], h.value[0], T()),
        Se(new Date(), y.value[1], h.value[1], T(false))
      ]) : l.value = Se(new Date(), y.value, h.value, T())) : e.monthPicker && !e.range ? l.value = rt(new Date(), R.value(0), B.value(0)) : e.multiCalendars ? _(new Date()) : e.yearPicker && !e.range && (l.value = new Date());
  }, j = (r) => {
    const k = getMonth(new Date(r)), A = getYear(new Date(r));
    if (O(0, k), L(0, A), e.multiCalendars > 0)
      for (let X = 1; X < e.multiCalendars; X++) {
        const Me = Dl(set(new Date(r), { year: R.value(X - 1), month: B.value(X - 1) }));
        O(X, Me.month), L(X, Me.year);
      }
  }, D = (r) => {
    if (l.value && Array.isArray(l.value))
      if (l.value.some((k) => ue(r, k))) {
        const k = l.value.filter((A) => !ue(A, r));
        l.value = k.length ? k : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > l.value.length || !e.multiDatesLimit) && l.value.push(r);
    else
      l.value = [r];
  }, $ = (r) => {
    if (Array.isArray(l.value) && l.value[0]) {
      const k = differenceInCalendarDays(r, l.value[0]), A = De(l.value[0], r) ? r : l.value[0], X = De(r, l.value[0]) ? r : l.value[0], xe = eachDayOfInterval({ start: A, end: X }).filter((it) => o(it)).length, Te = Math.abs(k < 0 ? k + 1 : k - 1) - xe;
      if (e.minRange && e.maxRange)
        return Te >= +e.minRange && Te <= +e.maxRange;
      if (e.minRange)
        return Te >= +e.minRange;
      if (e.maxRange)
        return Te <= +e.maxRange;
    }
    return true;
  }, i = (r) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && (De(r, l.value[0]) || ue(r, l.value[0])) ? [l.value[0], r] : e.fixedEnd && (ke(r, l.value[1]) || ue(r, l.value[1])) ? [r, l.value[1]] : l.value : [], s = () => {
    e.autoApply && a("autoApply");
  }, w = (r) => !eachDayOfInterval({ start: r[0], end: r[1] }).some((A) => o(A)), E = (r, k = false) => {
    if (!o(r.value) && !(!r.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return l.value = Tt(new Date(r.value), +e.weekStart), s();
      if (!e.range && !_e(y.value) && !_e(h.value)) {
        const A = Se(new Date(r.value), y.value, h.value, T());
        e.multiDates ? D(A) : l.value = A, n(), s();
      } else if (_e(y.value) && _e(h.value) && !e.multiDates) {
        let A = l.value ? l.value.slice() : [];
        if (A.length === 2 && !(e.fixedStart || e.fixedEnd) && (A = []), e.autoRange) {
          const X = [new Date(r.value), addDays(new Date(r.value), +e.autoRange)];
          w(X) && (k && j(r.value), A = X);
        } else
          e.fixedStart || e.fixedEnd ? A = i(new Date(r.value)) : A[0] ? $(new Date(r.value)) && (ke(new Date(r.value), new Date(A[0])) ? A.unshift(new Date(r.value)) : A[1] = new Date(r.value)) : A[0] = new Date(r.value);
        A.length && (A[0] && !A[1] ? A[0] = Se(A[0], y.value[0], h.value[0], T()) : (A[0] = Se(A[0], y.value[0], h.value[0], T()), A[1] = Se(A[1], y.value[1], h.value[1], T(false)), n()), l.value = A, A[0] && A[1] && e.autoApply && a("autoApply"));
      }
    }
  }, ee = (r) => {
    const k = r.find((A) => A.current);
    return k ? getISOWeek(k.value) : "";
  }, I = (r) => {
    !r.current && e.hideOffsetDates || (m.value = r.value);
  }, re = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return false;
        const k = addDays(m.value, +e.autoRange), A = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ue(A[1], new Date(r.value)) : ue(k, new Date(r.value));
      }
      return false;
    }
    return false;
  }, p = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        const k = addDays(m.value, +e.autoRange);
        if (e.hideOffsetDates && !r.current)
          return false;
        const A = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? De(r.value, A[0]) && ke(r.value, A[1]) : De(r.value, m.value) && ke(r.value, k);
      }
      return false;
    }
    return false;
  }, P = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return false;
        const k = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ue(k[0], r.value) : ue(m.value, r.value);
      }
      return false;
    }
    return false;
  }, N = (r) => {
    for (let k = r - 1; k >= 0; k--) {
      const A = subMonths(set(new Date(), { month: R.value(k + 1), year: B.value(k + 1) }), 1);
      Y(k, getMonth(A), getYear(A));
    }
    for (let k = r + 1; k <= e.multiCalendars - 1; k++) {
      const A = addMonths(set(new Date(), { month: R.value(k - 1), year: B.value(k - 1) }), 1);
      Y(k, getMonth(A), getYear(A));
    }
  }, pe = (r) => rt(new Date(), R.value(r), B.value(r)), Ee = (r, k) => {
    const A = e.monthPicker ? R.value(r) !== k.month : B.value(r) !== k.year;
    if (O(r, k.month), L(r, k.year), e.multiCalendars && !e.multiCalendarsSolo && N(r), e.monthPicker || e.yearPicker)
      if (e.range) {
        if (A) {
          let X = l.value ? l.value.slice() : [];
          X.length === 2 && X[1] !== null && (X = []), X.length ? ke(pe(r), X[0]) ? X.unshift(pe(r)) : X[1] = pe(r) : X = [pe(r)], l.value = X;
        }
      } else
        l.value = pe(r);
    n(), a("updateMonthYear", { instance: r, month: k.month, year: k.year }), At(e.multiCalendarsSolo ? r : void 0);
  }, Je = (r) => Se(r, y.value, h.value, T()), Ne = (r) => {
    bt(r) && bt(l.value) && _e(y.value) && _e(h.value) ? (r[0] && l.value[0] && (l.value[0] = Se(r[0], y.value[0], h.value[0], T())), r[1] && l.value[1] && (l.value[1] = Se(r[1], y.value[1], h.value[1], T(false)))) : e.multiDates && Array.isArray(l.value) ? l.value[l.value.length - 1] = Je(r) : !e.range && !It(r) && (l.value = Je(r)), a("timeUpdate");
  }, Ke = (r, k = true, A = false) => {
    const X = k ? r : y.value, Me = !k && !A ? r : h.value, xe = A ? r : M.value;
    if (e.range && It(l.value) && _e(X) && _e(Me) && _e(xe) && !e.disableTimeRangeValidation) {
      const Te = (We) => Se(l.value[We], X[We], Me[We], xe[We]), it = (We) => setMilliseconds(l.value[We], 0);
      if (ue(l.value[0], l.value[1]) && (isAfter(Te(0), it(1)) || isBefore(Te(1), it(0))))
        return;
    }
    if (y.value = X, h.value = Me, M.value = xe, l.value)
      if (e.multiDates) {
        const Te = Z();
        Te && Ne(Te);
      } else
        Ne(l.value);
    else
      e.timePicker && Ne(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, He = () => {
    m.value = null;
  }, Ze = (r) => Rn(l.value, e.range) && l.value[0] && m.value ? r ? De(m.value, l.value[0]) : ke(m.value, l.value[0]) : true, be = (r, k = true) => (e.range || e.weekPicker) && It(l.value) ? e.hideOffsetDates && !r.current ? false : ue(new Date(r.value), l.value[k ? 0 : 1]) : e.range ? ue(new Date(r.value), l.value && Array.isArray(l.value) ? k ? l.value[0] || null : l.value[1] : null) && (k ? !ke(m.value || null, Array.isArray(l.value) ? l.value[0] : null) : true) || ue(r.value, Array.isArray(l.value) ? l.value[0] : null) && Ze(k) : false, ot = (r, k) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? false : !r && !F(k) && !(!k.current && e.hideOffsetDates) && (e.range ? !be(k) && !be(k, false) : true), pt = (r, k, A) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? r ? false : A ? De(e.internalModelValue[0], k.value) : ke(e.internalModelValue[0], k.value) : false, ht = (r = false) => {
    e.autoApply && (e.monthPicker || e.yearPicker) && nextTick().then(() => {
      e.range ? a("autoApply", r || !l.value || l.value.length === 1) : a("autoApply", r);
    });
  }, f = (r, k) => {
    const A = set(new Date(), { month: R.value(k), year: B.value(k) }), X = r < 0 ? addMonths(A, 1) : subMonths(A, 1);
    oa(e.minDate, e.maxDate, getMonth(X), getYear(X), r < 0, e.preventMinMaxNavigation) && (Y(k, getMonth(X), getYear(X)), e.multiCalendars && !e.multiCalendarsSolo && N(k), At());
  }, ne = (r, k) => {
    e.monthChangeOnScroll && f(e.monthChangeOnScroll !== "inverse" ? -r.deltaY : r.deltaY, k);
  }, ce = (r, k, A = false) => {
    e.monthChangeOnArrows && e.vertical === A && ut(r, k);
  }, ut = (r, k) => {
    f(r === "right" ? -1 : 1, k);
  }, Qe = (r) => e.markers.find((k) => ue(Ie(r.value), Ie(k.date))), Lt = () => {
    e.range ? Rn(l.value, e.range) && (l.value && l.value[0] ? l.value = ke(new Date(), l.value[0]) ? [new Date(), l.value[0]] : [l.value[0], new Date()] : l.value = [new Date()]) : a("update:internalModelValue", new Date()), e.autoApply && a("selectDate");
  }, Gt = (r) => {
    r.length && r.length <= 2 && e.range && (l.value = r.map((k) => new Date(k)), e.autoApply && a("selectDate"));
  }, At = (r) => {
    r || r === 0 ? t.value[r].triggerTransition(R.value(r), B.value(r)) : t.value.forEach((k, A) => k.triggerTransition(R.value(A), B.value(A)));
  };
  return {
    today: c,
    hours: y,
    minutes: h,
    seconds: M,
    month: R,
    year: B,
    monthYearSelect: ht,
    isDisabled: o,
    updateTime: Ke,
    setHoverDate: I,
    getWeekNum: ee,
    selectDate: E,
    rangeActive: J,
    isActiveDate: F,
    updateMonthYear: Ee,
    isHoverRangeEnd: re,
    isAutoRangeInBetween: p,
    isAutoRangeStart: P,
    clearHoverDate: He,
    rangeActiveStartEnd: be,
    handleScroll: ne,
    getMarker: Qe,
    handleArrow: ce,
    handleSwipe: ut,
    selectCurrentDate: Lt,
    isHoverDate: ot,
    isHoverDateStartEnd: pt,
    presetDateRange: Gt
  };
};
var Rt = reactive({
  menuFocused: false,
  shiftKeyInMenu: false
});
var ua = () => ({
  setMenuFocused: (t) => {
    Rt.menuFocused = t;
  },
  getStore: () => Rt,
  setShiftKey: (t) => {
    Rt.shiftKeyInMenu !== t && (Rt.shiftKeyInMenu = t);
  }
});
var Wr = ["id", "aria-label", "onKeydown"];
var Ur = {
  key: 0,
  class: "dp__preset_ranges"
};
var Lr = ["onClick"];
var Gr = {
  key: 1,
  class: "dp__now_wrap"
};
var jr = defineComponent({
  __name: "DatepickerMenu",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, aa), pn), yn), {
    internalModelValue: { type: [Date, Array], default: null },
    multiCalendars: { type: Number, default: 0 },
    openOnTop: { type: Boolean, default: false }
  }),
  emits: [
    "update:internalModelValue",
    "closePicker",
    "selectDate",
    "dpOpen",
    "autoApply",
    "timeUpdate",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { emit: a }) {
    const n = e, t = useSlots(), c = ref(null), m = reactive({
      timePicker: !!(!n.enableTimePicker || n.timePicker || n.monthPicker),
      monthYearInput: !!n.timePicker,
      calendar: false
    }), v = ref([]), y = ref([]), h = ref(null), M = ref(null), R = ref(0), B = ref(false), Y = ref(0), O = inject(Wt), L = inject(ze), T = inject(Xe), { setMenuFocused: te, setShiftKey: l, getStore: o } = ua();
    onMounted(() => {
      var G;
      B.value = true, (G = n.presetRanges) != null && G.length || X();
      const d = we(M);
      if (d && !n.textInput && !n.inline && (te(true), z()), d) {
        const H = (q) => {
          !n.monthYearComponent && !n.timePickerComponent && q.preventDefault(), q.stopImmediatePropagation(), q.stopPropagation();
        };
        d.addEventListener("pointerdown", H), d.addEventListener("mousedown", H);
      }
      document.addEventListener("resize", X);
    }), onUnmounted(() => {
      document.removeEventListener("resize", X);
    });
    const { arrowRight: F, arrowLeft: J, arrowDown: _, arrowUp: U } = qe(), z = () => {
      const d = we(M);
      d && d.focus({ preventScroll: true });
    }, Z = () => {
      var d;
      ((d = n.flow) == null ? void 0 : d.length) && Y.value !== -1 && (Y.value += 1, a("flow-step", Y.value), wn());
    }, Q = () => {
      Y.value = -1;
    }, {
      updateTime: j,
      updateMonthYear: D,
      today: $,
      month: i,
      year: s,
      hours: w,
      minutes: E,
      seconds: ee,
      isDisabled: I,
      isActiveDate: re,
      selectDate: p,
      getWeekNum: P,
      setHoverDate: N,
      isHoverRangeEnd: pe,
      isAutoRangeInBetween: Ee,
      isAutoRangeStart: Je,
      rangeActive: Ne,
      clearHoverDate: Ke,
      rangeActiveStartEnd: He,
      monthYearSelect: Ze,
      handleScroll: be,
      handleArrow: ot,
      handleSwipe: pt,
      getMarker: ht,
      selectCurrentDate: f,
      isHoverDateStartEnd: ne,
      isHoverDate: ce,
      presetDateRange: ut
    } = Hr(n, a, Z, y), Qe = at(t, "calendar"), Lt = at(t, "action"), Gt = at(t, "timePicker"), At = at(t, "monthYear"), r = computed(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), k = computed(() => Fl(n.yearRange)), A = computed(() => Kl(n.locale, n.monthNameFormat)), X = () => {
      const d = we(c);
      d && (R.value = d.getBoundingClientRect().width);
    }, Me = computed(() => (d) => Il(i.value(d), s.value(d), +n.weekStart, n.hideOffsetDates)), xe = computed(() => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]), Te = computed(() => (d) => d === 1), it = computed(() => n.monthPicker || n.timePicker || n.yearPicker), We = computed(() => ({
      dp__flex_display: n.multiCalendars > 0
    })), da = computed(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    })), ca = computed(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly
    })), fa = computed(() => (d) => pa(Me, d)), ma = computed(() => ({
      locale: n.locale,
      weekNumName: n.weekNumName,
      weekStart: n.weekStart,
      weekNumbers: n.weekNumbers,
      customProps: n.customProps,
      calendarClassName: n.calendarClassName,
      specificMode: it.value,
      getWeekNum: P,
      multiCalendars: n.multiCalendars,
      modeHeight: n.modeHeight,
      internalModelValue: n.internalModelValue,
      noSwipe: n.noSwipe,
      vertical: n.vertical,
      dayNames: n.dayNames,
      monthChangeOnScroll: n.monthChangeOnScroll
    })), va = computed(() => ({
      dp__menu: true,
      dp__menu_index: !n.inline,
      dp__relative: n.inline,
      [n.menuClassName]: !!n.menuClassName
    })), ya = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : false, gt = () => n.modelAuto ? sa(n.internalModelValue) : true, pa = (d, G) => d.value(G).map((H) => __spreadProps(__spreadValues({}, H), {
      days: H.days.map((q) => {
        const x = I(q.value), wt = ce(x, q), et = n.range ? n.modelAuto ? ya() && re(q) : false : re(q), kn = n.highlight ? zn(q.value, n.highlight) : false, bn = (n.range || n.weekPicker) && (n.multiCalendars > 0 ? q.current : true) && !x && gt() && !(!q.current && n.hideOffsetDates) && !re(q) ? Ne(q) : false;
        return q.marker = ht(q), q.classData = {
          dp__cell_offset: !q.current,
          dp__pointer: !x && !(!q.current && n.hideOffsetDates),
          dp__active_date: et,
          dp__date_hover: wt,
          dp__date_hover_start: ne(wt, q, true),
          dp__date_hover_end: ne(wt, q, false),
          dp__range_between: bn && !n.weekPicker,
          dp__range_between_week: bn && n.weekPicker,
          dp__today: !n.noToday && ue(q.value, $.value) && q.current,
          dp__cell_disabled: x,
          dp__cell_auto_range: Ee(q),
          dp__cell_auto_range_start: Je(q),
          dp__cell_auto_range_end: pe(q),
          dp__range_start: n.multiCalendars > 0 ? q.current && He(q) && gt() : He(q) && gt(),
          dp__range_end: n.multiCalendars > 0 ? q.current && He(q, false) && gt() : He(q, false) && gt(),
          [n.calendarCellClassName]: !!n.calendarCellClassName,
          dp__cell_highlight: kn && !et,
          dp__cell_highlight_active: kn && et
        }, q;
      })
    })), ha = (d) => {
      d.stopPropagation(), d.preventDefault(), d.stopImmediatePropagation();
    }, ga = () => {
      n.escClose && a("closePicker");
    }, wa = (d) => {
      d.stopImmediatePropagation(), d.preventDefault(), n.spaceConfirm && a("selectDate");
    }, jt = (d) => {
      var G;
      (G = n.flow) != null && G.length && (m[d] = true, Object.keys(m).filter((H) => !m[H]).length || wn());
    }, wn = () => {
      n.flow[Y.value] === "month" && v.value[0] && v.value[0].toggleMonthPicker(true), n.flow[Y.value] === "year" && v.value && v.value[0].toggleYearPicker(true), n.flow[Y.value] === "calendar" && h.value && h.value.toggleTimePicker(false, true), n.flow[Y.value] === "time" && h.value && h.value.toggleTimePicker(true, true);
      const d = n.flow[Y.value];
      (d === "hours" || d === "minutes" || d === "seconds") && h.value && h.value.toggleTimePicker(true, true, d);
    }, Pt = (d) => {
      if (T != null && T.value) {
        if (d === "up")
          return U();
        if (d === "down")
          return _();
        if (d === "left")
          return J();
        if (d === "right")
          return F();
      } else
        d === "left" || d === "up" ? ot("left", 0, d === "up") : ot("right", 0, d === "down");
    }, ka = (d) => {
      l(d.shiftKey), !n.disableMonthYearSelect && d.code === "Tab" && d.target.classList.contains("dp__menu") && o().shiftKeyInMenu && (d.preventDefault(), d.stopImmediatePropagation(), a("closePicker"));
    };
    return (d, G) => (openBlock(), createBlock(Transition, {
      appear: "",
      name: unref(O).menuAppear,
      mode: "out-in",
      css: !!unref(O)
    }, {
      default: withCtx(() => [
        createBaseVNode("div", {
          id: d.uid ? `dp-menu-${d.uid}` : void 0,
          tabindex: "0",
          ref_key: "dpMenuRef",
          ref: M,
          role: "dialog",
          "aria-label": unref(L).menu,
          class: normalizeClass(unref(va)),
          onMouseleave: G[12] || (G[12] = (...H) => unref(Ke) && unref(Ke)(...H)),
          onClick: ha,
          onKeydown: [
            withKeys(ga, ["esc"]),
            withKeys(wa, ["space"]),
            G[13] || (G[13] = withKeys(withModifiers((H) => Pt("left"), ["prevent"]), ["left"])),
            G[14] || (G[14] = withKeys(withModifiers((H) => Pt("up"), ["prevent"]), ["up"])),
            G[15] || (G[15] = withKeys(withModifiers((H) => Pt("down"), ["prevent"]), ["down"])),
            G[16] || (G[16] = withKeys(withModifiers((H) => Pt("right"), ["prevent"]), ["right"])),
            ka
          ]
        }, [
          (d.disabled || d.readonly) && d.inline ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(ca))
          }, null, 2)) : createCommentVNode("", true),
          !d.inline && !d.teleportCenter ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(r))
          }, null, 2)) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(d.presetRanges.length ? "dp__menu_content_wrapper" : null)
          }, [
            d.presetRanges.length ? (openBlock(), createElementBlock("div", Ur, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(d.presetRanges, (H, q) => (openBlock(), createElementBlock("div", {
                key: q,
                style: normalizeStyle(H.style || {}),
                class: "dp__preset_range",
                onClick: (x) => unref(ut)(H.range)
              }, toDisplayString(H.label), 13, Lr))), 128))
            ])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "dp__instance_calendar",
              ref_key: "calendarWrapperRef",
              ref: c,
              role: "document"
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(We))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(xe), (H, q) => (openBlock(), createElementBlock("div", {
                  key: H,
                  class: normalizeClass(unref(da))
                }, [
                  !d.disableMonthYearSelect && !d.timePicker ? (openBlock(), createBlock(resolveDynamicComponent(d.monthYearComponent ? d.monthYearComponent : Kr), mergeProps({
                    key: 0,
                    ref_for: true,
                    ref: (x) => {
                      x && (v.value[q] = x);
                    }
                  }, {
                    months: unref(A),
                    years: unref(k),
                    filters: d.filters,
                    monthPicker: d.monthPicker,
                    month: unref(i)(H),
                    year: unref(s)(H),
                    customProps: d.customProps,
                    multiCalendars: e.multiCalendars,
                    multiCalendarsSolo: d.multiCalendarsSolo,
                    instance: H,
                    minDate: d.minDate,
                    maxDate: d.maxDate,
                    preventMinMaxNavigation: d.preventMinMaxNavigation,
                    internalModelValue: e.internalModelValue,
                    range: d.range,
                    reverseYears: d.reverseYears,
                    vertical: d.vertical,
                    yearPicker: d.yearPicker
                  }, {
                    onMount: G[0] || (G[0] = (x) => jt("monthYearInput")),
                    onResetFlow: Q,
                    onUpdateMonthYear: (x) => unref(D)(H, x),
                    onMonthYearSelect: unref(Ze),
                    onOverlayClosed: z
                  }), createSlots({ _: 2 }, [
                    renderList(unref(At), (x, wt) => ({
                      name: x,
                      fn: withCtx((et) => [
                        renderSlot(d.$slots, x, normalizeProps(guardReactiveProps(et)))
                      ])
                    }))
                  ]), 1040, ["onUpdateMonthYear", "onMonthYearSelect"])) : createCommentVNode("", true),
                  createVNode(nr, mergeProps({
                    ref_for: true,
                    ref: (x) => {
                      x && (y.value[q] = x);
                    }
                  }, unref(ma), {
                    "flow-step": Y.value,
                    "onUpdate:flow-step": G[1] || (G[1] = (x) => Y.value = x),
                    instance: H,
                    "mapped-dates": unref(fa)(H),
                    month: unref(i)(H),
                    year: unref(s)(H),
                    onSelectDate: (x) => unref(p)(x, !unref(Te)(H)),
                    onSetHoverDate: G[2] || (G[2] = (x) => unref(N)(x)),
                    onHandleScroll: (x) => unref(be)(x, H),
                    onHandleSwipe: (x) => unref(pt)(x, H),
                    onMount: G[3] || (G[3] = (x) => jt("calendar")),
                    onResetFlow: Q
                  }), createSlots({ _: 2 }, [
                    renderList(unref(Qe), (x, wt) => ({
                      name: x,
                      fn: withCtx((et) => [
                        renderSlot(d.$slots, x, normalizeProps(guardReactiveProps(__spreadValues({}, et))))
                      ])
                    }))
                  ]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleScroll", "onHandleSwipe"])
                ], 2))), 128))
              ], 2),
              createBaseVNode("div", null, [
                d.enableTimePicker && !d.monthPicker && !d.weekPicker ? (openBlock(), createBlock(resolveDynamicComponent(d.timePickerComponent ? d.timePickerComponent : Rr), mergeProps({
                  key: 0,
                  ref_key: "timePickerRef",
                  ref: h
                }, {
                  is24: d.is24,
                  hoursIncrement: d.hoursIncrement,
                  minutesIncrement: d.minutesIncrement,
                  hoursGridIncrement: d.hoursGridIncrement,
                  secondsIncrement: d.secondsIncrement,
                  minutesGridIncrement: d.minutesGridIncrement,
                  secondsGridIncrement: d.secondsGridIncrement,
                  noHoursOverlay: d.noHoursOverlay,
                  noMinutesOverlay: d.noMinutesOverlay,
                  noSecondsOverlay: d.noSecondsOverlay,
                  range: d.range,
                  filters: d.filters,
                  timePicker: d.timePicker,
                  hours: unref(w),
                  minutes: unref(E),
                  seconds: unref(ee),
                  customProps: d.customProps,
                  enableSeconds: d.enableSeconds,
                  fixedStart: d.fixedStart,
                  fixedEnd: d.fixedEnd,
                  modelAuto: d.modelAuto,
                  internalModelValue: e.internalModelValue
                }, {
                  onMount: G[4] || (G[4] = (H) => jt("timePicker")),
                  "onUpdate:hours": G[5] || (G[5] = (H) => unref(j)(H)),
                  "onUpdate:minutes": G[6] || (G[6] = (H) => unref(j)(H, false)),
                  "onUpdate:seconds": G[7] || (G[7] = (H) => unref(j)(H, false, true)),
                  onResetFlow: Q,
                  onOverlayClosed: z
                }), createSlots({ _: 2 }, [
                  renderList(unref(Gt), (H, q) => ({
                    name: H,
                    fn: withCtx((x) => [
                      renderSlot(d.$slots, H, normalizeProps(guardReactiveProps(x)))
                    ])
                  }))
                ]), 1040)) : createCommentVNode("", true)
              ])
            ], 512),
            d.showNowButton ? (openBlock(), createElementBlock("div", Gr, [
              d.$slots["now-button"] ? renderSlot(d.$slots, "now-button", {
                key: 0,
                selectCurrentDate: unref(f)
              }) : createCommentVNode("", true),
              d.$slots["now-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                role: "button",
                class: "dp__now_button",
                onClick: G[8] || (G[8] = (...H) => unref(f) && unref(f)(...H))
              }, toDisplayString(d.nowButtonLabel), 1))
            ])) : createCommentVNode("", true)
          ], 2),
          !d.autoApply || d.keepActionRow ? (openBlock(), createBlock(resolveDynamicComponent(d.actionRowComponent ? d.actionRowComponent : mr), mergeProps({ key: 2 }, {
            calendarWidth: R.value,
            selectText: d.selectText,
            cancelText: d.cancelText,
            internalModelValue: e.internalModelValue,
            range: d.range,
            previewFormat: d.previewFormat,
            inline: d.inline,
            monthPicker: d.monthPicker,
            timePicker: d.timePicker,
            customProps: d.customProps,
            multiCalendars: e.multiCalendars,
            menuMount: B.value,
            maxTime: d.maxTime,
            minTime: d.minTime,
            enableTimePicker: d.enableTimePicker,
            minDate: d.minDate,
            maxDate: d.maxDate,
            multiDates: d.multiDates,
            modelAuto: d.modelAuto,
            partialRange: d.partialRange
          }, {
            onClosePicker: G[9] || (G[9] = (H) => d.$emit("closePicker")),
            onSelectDate: G[10] || (G[10] = (H) => d.$emit("selectDate")),
            onInvalidSelect: G[11] || (G[11] = (H) => d.$emit("invalid-select"))
          }), createSlots({ _: 2 }, [
            renderList(unref(Lt), (H, q) => ({
              name: H,
              fn: withCtx((x) => [
                renderSlot(d.$slots, H, normalizeProps(guardReactiveProps(__spreadValues({}, x))))
              ])
            }))
          ]), 1040)) : createCommentVNode("", true)
        ], 42, Wr)
      ]),
      _: 3
    }, 8, ["name", "css"]));
  }
});
var Yt = ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Yt || {});
var zr = (e, a, n, t, c, m, v, y, h) => {
  const M = ref({
    top: "0",
    left: "0",
    transform: "none"
  }), R = ref(false), B = 390, Y = (_) => {
    const U = _.getBoundingClientRect();
    return {
      left: U.left + window.scrollX,
      top: U.top + window.scrollY
    };
  }, O = (_) => {
    const U = _.getBoundingClientRect();
    let z = 0, Z = 0;
    for (; _ && !isNaN(_.offsetLeft) && !isNaN(_.offsetTop); )
      z += _.offsetLeft - _.scrollLeft, Z = U.top + _.scrollTop, _ = _.offsetParent;
    return { top: Z, left: z };
  }, L = (_, U) => {
    M.value.left = `${_ + U}px`, M.value.transform = "translateX(-100%)";
  }, T = (_) => {
    M.value.left = `${_}px`, M.value.transform = "translateX(0)";
  }, te = (_, U) => {
    e === Yt.left && T(_), e === Yt.right && L(_, U), e === Yt.center && (M.value.left = `${_ + U / 2}px`, M.value.transform = "translateX(-50%)");
  }, l = () => {
    const _ = we(c);
    if (_) {
      const U = window.innerHeight, { top: z } = a ? O(_) : Y(_), { left: Z, width: Q, top: j, height: D } = _.getBoundingClientRect(), $ = U - j - D;
      M.value.top = j > $ ? `${z - B}px` : `${z}px`, te(Z, Q);
    }
  }, o = () => {
    M.value.left = "50%", M.value.top = "50%", M.value.transform = "translate(-50%, -50%)", M.value.position = "fixed";
  }, F = (_ = true) => {
    if (!m) {
      if (y.value)
        return o();
      const U = we(c);
      if (a && typeof a != "boolean")
        M.value = a(U);
      else if (U) {
        const { left: z, width: Z, height: Q } = U.getBoundingClientRect(), { top: j } = a ? O(U) : Y(U);
        M.value.top = `${Q + j + +v}px`, te(z, Z), _ && n && J();
      }
    }
  }, J = () => {
    const _ = we(c);
    if (_ && n && !m) {
      const { height: U, top: z, left: Z, width: Q } = _.getBoundingClientRect(), { top: j } = a ? O(_) : Y(_), $ = window.innerHeight - z - U, i = we(t);
      if (i) {
        const { height: s, left: w, right: E } = i.getBoundingClientRect(), ee = s + U;
        ee > z && ee > $ ? z < $ ? (F(false), R.value = false) : (M.value.top = `${j - s - +v}px`, R.value = true) : ee > $ ? (M.value.top = `${j - s - +v}px`, R.value = true) : (F(false), R.value = false), w < 0 ? T(Z) : E > document.documentElement.clientWidth && L(Z, Q);
      }
    }
    h("recalculatePosition");
  };
  return { openOnTop: R, menuPosition: M, setMenuPosition: F, setInitialPosition: l, recalculatePosition: J };
};
var Xr = (e, a, n, t, c, m, v, y, h, M, R, B, Y, O, L, T, te) => {
  const l = ref(""), o = ref();
  watch(o, () => {
    te("internalModelChange", o.value);
  });
  const F = (i) => [Z(i[0]), i[1] ? Z(i[1]) : null], J = (i) => {
    let s = null;
    i ? a ? lr(i) && "hours" in i[0] && "minutes" in i[0] ? s = [
      Se(null, +i[0].hours, +i[0].minutes, +i[0].seconds),
      Se(null, +i[1].hours, +i[1].minutes, +i[1].seconds)
    ] : ar(i) && (s = Se(null, +i.hours, +i.minutes, +i.seconds)) : n ? rr(i) && "month" in i[0] && "year" in i[0] ? (s = [rt(null, +i[0].month, +i[0].year)], i[1] ? s[1] = rt(null, +i[1].month, +i[1].year) : !i[1] && c && (s[1] = null)) : sr(i) && "month" in i && "year" in i && (s = rt(null, +i.month, +i.year)) : Y ? Array.isArray(i) ? s = [
      setYear(new Date(), i[0]),
      !i[1] && c ? null : setYear(new Date(), i[1])
    ] : s = setYear(new Date(), i) : M && Array.isArray(i) ? s = i.map((w) => Z(w)) : B && Array.isArray(i) ? s = [new Date(i[0]), new Date(i[1])] : t ? T ? Array.isArray(i) ? s = F(i) : s = [Z(i), null] : or(i, c) && (s = F(i)) : ir(i) && (s = Z(i)) : s = null, rn(s) ? (o.value = s, U()) : (o.value = null, l.value = "");
  }, _ = () => Gn(e, m, y, n, a, B, Y, v), U = () => {
    if (!o.value)
      l.value = "";
    else if (!e || typeof e == "string") {
      const i = _();
      Array.isArray(o.value) && M ? l.value = o.value.map((s) => mt(s, i, h == null ? void 0 : h.value)).join("; ") : l.value = mt(o.value, i, h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator, T);
    } else
      a ? l.value = e(sn(o.value)) : n ? l.value = e(Cn(o.value)) : l.value = e(o.value);
  }, z = () => o.value ? t ? c ? o.value.length >= 1 : o.value.length === 2 : !!o.value : false, Z = (i) => {
    if (R) {
      const s = new Date(i);
      return R === "preserve" ? new Date(s.getTime() + s.getTimezoneOffset() * 6e4) : s;
    }
    return L ? L === "date" || L === "timestamp" ? new Date(i) : L === "format" && (typeof e == "string" || !e) ? parse(i, _(), new Date()) : parse(i, L, new Date()) : new Date(i);
  }, Q = (i) => L ? L === "timestamp" ? +i : L === "format" && (typeof e == "string" || !e) ? mt(i, _(), h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator) : mt(i, L, h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator) : i, j = (i) => {
    te("update:modelValue", i);
  }, D = () => [
    Q(o.value[0]),
    o.value[1] ? Q(o.value[1]) : null
  ];
  return {
    parseExternalModelValue: J,
    formatInputValue: U,
    internalModelValue: o,
    inputValue: l,
    emitModelValue: () => {
      if (n)
        j(Cn(o.value));
      else if (a)
        j(sn(o.value));
      else if (B)
        j(o.value);
      else if (Y)
        j(Array.isArray(o.value) ? [
          getYear(o.value[0]),
          o.value[1] ? getYear(o.value[1]) : null
        ] : getYear(o.value));
      else {
        if (o.value && t && c && o.value.length === 1 && o.value.push(null), R) {
          let i;
          if (Array.isArray(o.value)) {
            const s = (w) => w && Zt(w, R === "preserve");
            T ? i = o.value[1] ? o.value.map(s) : Zt(o.value[0], R === "preserve") : i = o.value.map(s);
          } else
            i = Zt(o.value, R === "preserve");
          return j(i);
        }
        Array.isArray(o.value) && !M ? j(T ? o.value[1] ? D() : Q(o.value[0]) : D()) : Array.isArray(o.value) && M ? j(o.value.map((i) => Q(i))) : j(Q(o.value));
      }
      U();
    },
    checkBeforeEmit: z
  };
};
var qr = typeof window < "u" ? window : void 0;
var an = () => {
};
var Jr = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false;
var Zr = (e, a, n, t) => {
  if (!e)
    return an;
  let c = an;
  const m = watch(() => unref(e), (y) => {
    c(), y && (y.addEventListener(a, n, t), c = () => {
      y.removeEventListener(a, n, t), c = an;
    });
  }, { immediate: true, flush: "post" }), v = () => {
    m(), c();
  };
  return Jr(v), v;
};
var Qr = (e, a, n, t = {}) => {
  const { window: c = qr, event: m = "pointerdown" } = t;
  return c ? Zr(c, m, (y) => {
    const h = we(e), M = we(a);
    !h || !M || h === y.target || y.composedPath().includes(h) || y.composedPath().includes(M) || n(y);
  }, { passive: true }) : void 0;
};
var xr = defineComponent({
  __name: "VueDatePicker",
  props: __spreadValues({}, Cl),
  emits: [
    "update:modelValue",
    "textSubmit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internalModelChange",
    "recalculatePosition",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = useSlots(), m = ref(false), v = toRef(t, "modelValue"), y = ref(null), h = ref(null), M = toRef(t, "teleportCenter");
    provide(vn, t.autoApply);
    const R = computed(() => t.formatLocale);
    provide(Jn, R), provide(qn, toRef(t, "textInput")), provide(Xe, toRef(t, "arrowNavigation")), onMounted(() => {
      J(t.modelValue), t.inline || (window.addEventListener("scroll", P), window.addEventListener("resize", N)), t.inline && (m.value = true);
    }), onUnmounted(() => {
      t.inline || (window.removeEventListener("scroll", P), window.removeEventListener("resize", N));
    });
    const B = at(c, "all"), Y = at(c, "input");
    watch(v, () => {
      J(v.value);
    }, { deep: true });
    const { openOnTop: O, menuPosition: L, setMenuPosition: T, recalculatePosition: te, setInitialPosition: l } = zr(t.position, t.altPosition, t.autoPosition, y, h, t.inline, t.offset, M, n), {
      internalModelValue: o,
      inputValue: F,
      parseExternalModelValue: J,
      emitModelValue: _,
      checkBeforeEmit: U,
      formatInputValue: z
    } = Xr(t.format, t.timePicker, t.monthPicker, t.range, t.partialRange, t.is24, t.enableTimePicker, t.enableSeconds, R, t.multiDates, t.utc, t.weekPicker, t.yearPicker, t.textInputOptions, t.modelType, t.modelAuto, n), { clearArrowNav: Z } = qe(), { setMenuFocused: Q, setShiftKey: j } = ua(), D = computed(() => ({
      dp__main: true,
      dp__theme_dark: t.dark,
      dp__theme_light: !t.dark,
      dp__flex_display: t.inline,
      dp__flex_display_with_input: t.inlineWithInput
    })), $ = computed(() => Vn(t.format) ? t.format : Gn(null, t.is24, t.enableSeconds, t.monthPicker, t.timePicker, t.weekPicker, t.yearPicker, t.enableTimePicker)), i = computed(() => t.previewFormat ? t.previewFormat : Vn($.value) ? $.value : t.format), s = computed(() => typeof t.transitions == "boolean" ? t.transitions ? _n({}) : false : _n(t.transitions));
    provide(Wt, s);
    const w = computed(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), E = computed(() => Object.assign(Wl(), t.textInputOptions)), ee = computed(() => jl(t.ariaLabels));
    provide(ze, ee);
    const I = computed(() => Ul(t.filters)), re = computed(() => {
      const f = (ne) => {
        const ce = {
          hours: getHours(new Date()),
          minutes: getMinutes(new Date()),
          seconds: getSeconds(new Date())
        };
        return Object.assign(ce, ne);
      };
      return t.range ? t.startTime && Array.isArray(t.startTime) ? [f(t.startTime[0]), f(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? f(t.startTime) : null;
    }), p = computed(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), P = () => {
      m.value && (t.closeOnScroll ? be() : t.autoPosition ? T() : window.removeEventListener("scroll", P));
    }, N = () => {
      m.value && T();
    }, pe = () => {
      !t.disabled && !t.readonly && (l(), m.value = true, nextTick().then(() => {
        T(), m.value && n("open");
      }), m.value || Ze(), J(t.modelValue));
    }, Ee = () => {
      F.value = "", Ze(), n("update:modelValue", null), n("cleared"), be();
    }, Je = () => {
      const { validate: f } = Xn(t.minDate, t.maxDate, t.disabledDates, t.allowedDates, I.value, t.disabledWeekDays, t.yearRange), ne = o.value;
      return !ne || !Array.isArray(ne) && f(ne) ? true : Array.isArray(ne) ? ne.length === 2 && f(ne[0]) && f(ne[1]) ? true : !!f(ne[0]) : false;
    }, Ne = () => {
      U() && Je() ? (_(), be()) : n("invalid-select", o.value);
    }, Ke = (f) => {
      _(), t.closeOnAutoApply && !f && be();
    }, He = (f = false) => {
      t.autoApply && (!t.enableTimePicker || t.monthPicker || t.yearPicker ? true : on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate)) && Je() && (t.range && Array.isArray(o.value) ? (t.partialRange || o.value.length === 2) && Ke(f) : Ke(f));
    }, Ze = () => {
      o.value = null;
    }, be = () => {
      t.inline || (m.value && (m.value = false, Q(false), j(false), Z(), n("closed"), l(), F.value && J(v.value)), Ze(), h.value && h.value.focusInput());
    }, ot = (f, ne) => {
      if (!f) {
        o.value = null;
        return;
      }
      o.value = f, ne && (Ne(), n("textSubmit"));
    }, pt = () => {
      t.autoApply && on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate) && _();
    }, ht = () => m.value ? be() : pe();
    return Qr(y, h, be), a({
      closeMenu: be,
      selectDate: Ne,
      clearValue: Ee,
      openMenu: pe,
      onScroll: P,
      formatInputValue: z
    }), (f, ne) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(D))
    }, [
      createVNode(Ol, mergeProps({
        ref_key: "inputRef",
        ref: h
      }, {
        placeholder: f.placeholder,
        hideInputIcon: f.hideInputIcon,
        readonly: f.readonly,
        disabled: f.disabled,
        inputClassName: f.inputClassName,
        clearable: f.clearable,
        state: f.state,
        inline: f.inline,
        inlineWithInput: f.inlineWithInput,
        textInput: f.textInput,
        textInputOptions: unref(E),
        range: f.range,
        isMenuOpen: m.value,
        pattern: unref($),
        autoApply: f.autoApply,
        uid: f.uid,
        required: f.required,
        name: f.name,
        autocomplete: f.autocomplete
      }, {
        "input-value": unref(F),
        "onUpdate:input-value": ne[0] || (ne[0] = (ce) => isRef(F) ? F.value = ce : null),
        onClear: Ee,
        onOpen: pe,
        onSetInputDate: ot,
        onSetEmptyDate: unref(_),
        onSelectDate: Ne,
        onToggle: ht,
        onClose: be,
        onFocus: ne[1] || (ne[1] = (ce) => f.$emit("focus")),
        onBlur: ne[2] || (ne[2] = (ce) => f.$emit("blur"))
      }), createSlots({ _: 2 }, [
        renderList(unref(Y), (ce, ut) => ({
          name: ce,
          fn: withCtx((Qe) => [
            renderSlot(f.$slots, ce, normalizeProps(guardReactiveProps(Qe)))
          ])
        }))
      ]), 1040, ["input-value", "onSetEmptyDate"]),
      m.value ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: f.teleport,
        disabled: f.inline
      }, [
        m.value ? (openBlock(), createBlock(jr, mergeProps({
          key: 0,
          ref_key: "dpMenuRef",
          ref: y,
          class: unref(w),
          style: unref(L)
        }, {
          weekNumbers: f.weekNumbers,
          weekStart: f.weekStart,
          disableMonthYearSelect: f.disableMonthYearSelect,
          menuClassName: f.menuClassName,
          calendarClassName: f.calendarClassName,
          yearRange: f.yearRange,
          range: f.range,
          multiCalendars: unref(p),
          multiCalendarsSolo: f.multiCalendarsSolo,
          multiStatic: f.multiStatic,
          calendarCellClassName: f.calendarCellClassName,
          enableTimePicker: f.enableTimePicker,
          is24: f.is24,
          hoursIncrement: f.hoursIncrement,
          minutesIncrement: f.minutesIncrement,
          hoursGridIncrement: f.hoursGridIncrement,
          minutesGridIncrement: f.minutesGridIncrement,
          minDate: f.minDate,
          maxDate: f.maxDate,
          autoApply: f.autoApply,
          selectText: f.selectText,
          cancelText: f.cancelText,
          previewFormat: unref(i),
          locale: f.locale,
          weekNumName: f.weekNumName,
          disabledDates: f.disabledDates,
          filters: unref(I),
          minTime: f.minTime,
          maxTime: f.maxTime,
          inline: f.inline,
          openOnTop: unref(O),
          monthPicker: f.monthPicker,
          timePicker: f.timePicker,
          monthNameFormat: f.monthNameFormat,
          startDate: f.startDate,
          startTime: unref(re),
          monthYearComponent: f.monthYearComponent,
          timePickerComponent: f.timePickerComponent,
          actionRowComponent: f.actionRowComponent,
          customProps: f.customProps,
          hideOffsetDates: f.hideOffsetDates,
          autoRange: f.autoRange,
          noToday: f.noToday,
          noHoursOverlay: f.noHoursOverlay,
          noMinutesOverlay: f.noMinutesOverlay,
          disabledWeekDays: f.disabledWeekDays,
          allowedDates: f.allowedDates,
          showNowButton: f.showNowButton,
          nowButtonLabel: f.nowButtonLabel,
          monthChangeOnScroll: f.monthChangeOnScroll,
          markers: f.markers,
          uid: f.uid,
          modeHeight: f.modeHeight,
          enableSeconds: f.enableSeconds,
          secondsIncrement: f.secondsIncrement,
          secondsGridIncrement: f.secondsGridIncrement,
          noSecondsOverlay: f.noSecondsOverlay,
          escClose: f.escClose,
          spaceConfirm: f.spaceConfirm,
          monthChangeOnArrows: f.monthChangeOnArrows,
          textInput: f.textInput,
          disabled: f.disabled,
          readonly: f.readonly,
          multiDates: f.multiDates,
          presetRanges: f.presetRanges,
          flow: f.flow,
          preventMinMaxNavigation: f.preventMinMaxNavigation,
          minRange: f.minRange,
          maxRange: f.maxRange,
          fixedStart: f.fixedStart,
          fixedEnd: f.fixedEnd,
          multiDatesLimit: f.multiDatesLimit,
          reverseYears: f.reverseYears,
          keepActionRow: f.keepActionRow,
          weekPicker: f.weekPicker,
          noSwipe: f.noSwipe,
          vertical: f.vertical,
          arrowNavigation: f.arrowNavigation,
          yearPicker: f.yearPicker,
          disableTimeRangeValidation: f.disableTimeRangeValidation,
          dayNames: f.dayNames,
          modelAuto: f.modelAuto,
          highlight: f.highlight,
          partialRange: f.partialRange,
          teleportCenter: f.teleportCenter
        }, {
          internalModelValue: unref(o),
          "onUpdate:internalModelValue": ne[3] || (ne[3] = (ce) => isRef(o) ? o.value = ce : null),
          onClosePicker: be,
          onSelectDate: Ne,
          onDpOpen: unref(te),
          onAutoApply: He,
          onTimeUpdate: pt,
          onFlowStep: ne[4] || (ne[4] = (ce) => f.$emit("flow-step", ce)),
          onUpdateMonthYear: ne[5] || (ne[5] = (ce) => f.$emit("updateMonthYear", ce)),
          onInvalidSelect: ne[6] || (ne[6] = (ce) => f.$emit("invalid-select", unref(o)))
        }), createSlots({ _: 2 }, [
          renderList(unref(B), (ce, ut) => ({
            name: ce,
            fn: withCtx((Qe) => [
              renderSlot(f.$slots, ce, normalizeProps(guardReactiveProps(__spreadValues({}, Qe))))
            ])
          }))
        ]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : createCommentVNode("", true)
      ], 8, ["to", "disabled"])) : createCommentVNode("", true)
    ], 2));
  }
});
var ia = (() => {
  const e = xr;
  return e.install = (a) => {
    a.component("Vue3DatePicker", e);
  }, e;
})();
var es = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: ia
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(es).forEach(([e, a]) => {
  e !== "default" && (ia[e] = a);
});

// dep:@vuepic_vue-datepicker
var vuepic_vue_datepicker_default = ia;
export {
  vuepic_vue_datepicker_default as default
};
//# sourceMappingURL=@vuepic_vue-datepicker.js.map
